\documentclass[10pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
} 

\author{Helena Brekalo}
\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
\textsc{\LARGE KU Leuven}\\[1.5cm] % Name of your university/college

\begin{figure}[ht!]
\centering
\includegraphics[width=30mm]{logo_theo.png}
\label{kulogo}
\end{figure}

\textsc{\Large Ma Ingenieurswetenschappen: Computerwetenschappen}\\[0.5cm] % Major heading such as course name


\HRule \\[0.4cm]
{ \huge \bfseries Digitale Elektronica en Processoren}\\[0.4cm]
\HRule \\[1.5cm]


\textsc{\Large Lesnota's}\\[0.5cm] % Minor heading such as course title


\large \emph{Author:}\\
Helena \textsc{Brekalo}\\[3cm]

{\large 2015-2016}\\[3cm] % Date

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\tableofcontents
\clearpage

\chapter{Les 1}
\section{Slides: 1\_Intro}

\paragraph{Slide 6:} Die meerdere cores zorgen voor een grotere verwerkingskracht. Voorbeeld van de smartphone: het blokschema is hier van belang. Je hebt een aantal dingen die contact maken met de buitenwereld. In het blauw: de telecommunicatie, het echte gsm-gebeuren. Je hebt ook ergens iets draadloos (WiFi) (bruin). Het is dus heel specifieke hardware die een bepaalde taak vervult, die is geoptimaliseerd om \'e\'e ding heel goedkoop, eenvoudig en compact te doen. Je hebt ook geheugen en powermanagement. De donkere blokjes in het midden zijn een algemene processor (rechts) die redelijk flexibel is en een specifieke processor (links) die alle signaalverwerking doet.

\paragraph{Slide 7:} SoC: alles op 1 enkele chip. Heel wat verschillende dingen zijn weer aanwezig. 3 grote stukken: opgelijst met tweekleurige pijltjes:
\begin{itemize}
\item Programmeerbare processor: die kan vanalles en nog wat doen.
\item Niet-programmeerbare processoren: specifieke processoren voor beeldverwerking bv. Ze zijn meestal beperkt programmeerbaar, om \'e\'e specifieke familie van problemen op te lossen.
\item Controle-eenheden.
\end{itemize}
Waarom die tweede groep? $\rightarrow$ Veel goedkoper! Je hebt ongeveer 1000 keer zoveel energie nodig op een programmeerbare processor dan bij een niet-programmeerbare. Bv i.p.v. 1W 1kW.

\paragraph{Slide 8:} We vertrekken van een doel: we hebben een algoritme of beschrijving op gedragsniveau. Dat is een combinatie van software en hardware. Sommige dingen doe je via software omwille van flexibiliteit, andere dingen doen we via hardware. Dat is allemaal afhankelijk van elkaar. De keuze van welk programma je gaat gebruiken zal impact zal hebben op de hardware en de hardware die je hebt zal bepalen hoe programmeerbaar het is. Men spreekt daarom van hardware-software codesign. hardware gaat ook interrageren met wat als algoritme gebruikt kan worden: sommige dingen zijn makkelijk te implementeren, andere moeilijker. Het kan zinvol zijn om de algoritmen eventueel wat aan te passen. \\
Bij de hardware heb je een digitaal en een analoog gedeelte. Bij een smartphone: alle telecommunicatie is analoog: continue signalen. Wat in het midden stond was meer digitaal: meer berekeningen. Beiden moeten ge\"implementeerd worden, gewoonlijk op dezelfde componenten, momenteel gebeurt dat met transistoren en dat moet vertaald worden naar een chip (ge\"integreerde schakeling). Wij gaan het hier enkel hebben over het linkerdeel. Dit kan nog opgesplitst worden in 3 lagen. Poorten liggen het dichtst aan bij transistoren, die kunnen gebruikt worden om basiscomponenten te maken (bv. basisprocessoren) die samengezet kunnen worden om systemen te bouwen.

\paragraph{Slide 9:} Het gaat in eerste instantie over het ontwerp van elektronische schakelingen. We gaan daar ook voorbeelden van zien. Hardware kan je beschrijven via een schema, maar ook via een taal: hardware-beschrijvingstalen. We gaan die ook bekijken. We gaan dit ook toepassen in oefeningen en labo's.

\paragraph{Slide 10:} Drie grote blokken:
\begin{enumerate}
\item Basis: principes van digitaal ontwerp en hoe je dat doet met elektronica. Veel van de dingen die we gaan zien kan ook met andere dingen dan elektornica. 
\item Dan gaan we zien hoe we daar schakelingen mee kunnen maken. Eerst zonder geheugen en dan met geheugen. 
\item Dan gaan ingewikkeldere algoritmen implementeren en dan kijken hoe dat ge\"implementeerd kan worden.
\end{enumerate}

\paragraph{Slide 11:} Vereiste voorkennis.

\paragraph{Examen:} FSM is schriftelijk, rest is ook mondeling. Eerst wordt de theorie ondervraagd, dan de vertaling van een algoritme (vraag 1).

\section{Slides: 2\_Digitaal\_Ontwerp}

\paragraph{Slide 3:} Documentatie is heel belangrijk: als handleiding en om bij te houden wat geprobeerd is (en wat dus wel en niet werkt).

\paragraph{Slide 4:} Specificatie: beschrijving, heel dikwijls in natuurlijke taal, van welke berekeningen je wilt/hebt. Specificaties zijn in de meeste gevallen te algemeen en te onvolledig om er een duidelijke implementatie van te maken omdat het in veel gevallen te weinig specifieert. Er kunnen heel veel verschillende algoritmes gebruikt worden om een probleem op te lossen. Langs de andere kant gaat het soms al zaken vastleggen waarvan je niet de bedoeling had dat het vastgelegd werd (bv. vaste of vlottende komma). 

\paragraph{Slide 5:} Het geheel is dikwijls iteratief (vandaar de lus). Synthese: schakeling maken. Het is niet het bouwen van de schakeling maar een iets algemenere beschrijving maken. Normaal doe je geen synthese van een algemene beschrijving om onmiddelijk op een ge\"integreerde schakeling uit te komen. Je gaat daarom in niveau's werken: in stapjes oplossen: eerst op het hoogste niveau kijken en een heel algemene beschrijving doen: ik wil een FFT implementeren, wat houdt dat in, wat voor verwerking heb ik nodig?\\ Vervolgens ga je een niveau lager: welke blokken heb je allemaal nodig? Die ga je verder verfijnen tot op een niveau waarop je blokken krijgt waarvan je ongeveer weet hoe die ge\"implementeerd moeten worden. Je gaat dat dan nog verder opsplisten (in poorten en flip flops). Dan komt er nog een nivau onder: hoe maak ik een poort (met transistoren)? \\
Door dat in stukjes te doen en elk stukje per keer op te lossen is het doenbaar: je maak ter hapklare brokken van die je kan verwerken. Wij gaan de twee middenste niveau's vooral bekijken. 

\paragraph{Slide 6:} Belangrijk is het gebruik van bibliotheken: de kennis van anderen, dingen die je zelf niet meer moet doen. We gaan componenten hergebruiken. Als iemand iets nog niet gedaan heeft ga je het zelf maken, het in de bibliotheek steken zodat het hergebruikt kan worden. Die bibliotheken komen op ieder van de niveau's terug. Waarom zo belangrijk? $\rightarrow$ Wet van Moore.\\
We krijgen dus heel wat mogelijkheden jaarlijks erbij. Uiteindelijk zal dat wel gaan vastlopen. Wat ontstaat er nu? We krijgen elk jaar meer en meer mogelijkheden. We kunnen dit jaar een twee keer zo complexe schakeling maken dan 2 jaar geleden. Een meer complexe schakeling ontwerpen duurt meer dan twee keer zo lang want je raakt volledig het overzicht kwijt. De processoren aan de rechterkant teken je niet zomaar op 1 blad, dat duurt eindeloos lang. De enige manier om dat doenbaar te krijgen is door zoveel mogelijk te hergebruiken. Dit betekent dat het ontwerpen altijd achterloopt op de mogelijkheden die we hebben. 

\paragraph{Slide 7:} Blauw: wat we als verwerkingskracht kunnen doen, dit is wat ons interesseert. Meer cores op 1 chip: kost qua ontwerpinspanning niet zoveel werk. In de toekomst gaan we dus veel meer in parallel moeten laten gebeuren. Vermogen (Typical Power): is belangrijk want je kan dat niet eindeloos laten toenemen. Het vermogengebruik hangt af van de spanning in het kwadraat (V), de grootte van de chip ( C) en de frequentie (f). Hoe hoger de frequentie, hoe meer verwerkingskracht je hebt. Oorspronkelijk zaten we aan minder dan een Watt voor een ge\"integreerde schakeling zitten we nu aan 100 Watt. \\
We willen het vermogen dus constant houden maar dat heeft zijn impact op de frequentie en de verwerkingskracht. 

\paragraph{Slide 8:} Analyse: nagaan of het voldoet aan de specificaties. Dat doe je niet helemaal op het einde: het ontwerp gebeurt in stapjes en ga je telkens testen of dat het wel voldoet aan zijn specificaties op dat niveau. Dat betekent meer dan alleen maar testen of het doet wat het moet doen. Het functionele is eigenlijk maar een aspect ervan, er hoort veel meer bij: het vermogenverbruik bv. mag niet eindeloos oplopen. De snelheid waaraan dat kan werken, de kostprijs,… Dat soort zaken moet ook nagekeken worden. De testbaarheid is ook een belangrijke factor.

\paragraph{Slide 10:} Schakelingen gebaseerd op logische werking. We werken met discrete signalen en in de praktijk met bits: de waarden worden enkel 0 of 1. 

\paragraph{Slide 11:} Er is een verband tussen het al dan niet ingedrukt zijn van de knop en de uitgang. Je kan ook andere functies hebben: een complementaire die in rusttoestand een verbinding maakt: in rusttoestand is er een verbinding en brandt de lamp. Druk je de knop in, gaat de lamp uit. Er zijn heel wat verschillende manieren om een logische functie aan te duiden, afhankelijk van welk boek/welke beschrijving je neemt: onderaan: verschillende manieren om NOT te schrijven. Wij gebruiken normaal altijd een accent (').

\paragraph{Slide 12:} Andere logische functies: 
\begin{itemize}
\item AND: schakelaars in serie zetten en dan brandt de lamp alleen als beide knoppen ingedrukt zijn.
\item OR: schakelaars in parallel zetten: de lamp brandt als een van de twee schakelaars ingedrukt is of ze alletwee ingedrukt zijn.
\end{itemize}
We kunnen complexere schakelaars maken: je kan een lamp bedienen vanop twee plaatsen, dat is ook een logische functie: XOR. De lamp zal branden als de ene of de andere knop ingedrukt is, maar niet als ze alletwee ingedrukt zijn of alletwee niet ingedrukt zijn. Voor andere logische functies kan je ze herleiden tot de twee eersten (AND en OR): XOR is een parallelschakeling van een serieschakeling: je hebt alleen maar een parallel- en een serieschakeling nodig en de inverter. We hebben dus maar 3 logische schakelingen nodig: het inverse (NOT), een AND en een OR, daarmee kunnen we alle logische functies bepalen.

\paragraph{Slide 13:} Hoe beschrijven we de functionaliteit van zo'n logische schakeling? $\rightarrow$ Met een waarheidstabel: een opsomming van alle mogelijke combinaties aan de ingang en daarbij wordt aangegeven wat de uitgang is. Vermits een waarheidstabel eigenlijk de functionaliteit beschrijft zijn twee implementaties met eenzelfde waarheidstabel volledig equivalent, die doen exact hetzelfde. Je kan dus ook zeggen dat als je een waarheidstabel hebt die je op verschillende manieren kan maken, je aan de hand van die waarheidstabellen verschillende schakelingen kan maken. Het is dus niet zo dat bij een functionaliteit altijd maar 1 implementatie mogelijk is, er zijn meerdere mogelijkheden.

\paragraph{Slide 14:} Logische poorten: meer dan de inverter, de AND en de OR-poort heb je in principe niet nodig, hoewel men dikwijls gebruik maakt van complexe poorten. In CMOS is het bv. goedkoper om met complexe poorten te werken dan met de basispoorten. Een logische schakeling is dan een combinatie van die poorten. Je kan dit met een schema doen of een programma.

\paragraph{Slide 15:} Als je zo'n schema hebt kan je ook makkelijk de waarheidstabel opstellen. Je gaat gewoon op alle tussenliggende draden kijken wat er gebeurt voor elke combinatie van ingangen aan de uitgangen: dus aan a en b en daarna f en op die manier kan je de functionaliteit gaan beschrijven van wat die schakeling doet. \\
Dat is een ding: je hebt een schakeling en je weet wat die doet. \\
Meestal wil men het omgekeerde: men wil het omgekeerde, wat is er de schakeling voor? Maar zelfs dit is een onvolledige beschrijving van wat die schakeling doet want het beschrijft alleen de logische functie en in praktijk is een schakeling meer dan alleen zijn logische functie. \\
Een schakeling wordt altijd nog aangevuld met een tijdsgedrag. Het gaat er hier niet over hoe traag die poorten werken, het is niet dat als er bij x iets verandert, er onmiddelijk iets bij b verandert, dat gebeurt nooit ogenblikkelijk; ogenblikkelijk bestaat niet: het duurt altijd een zekere tijd. Dat betekent dat als we iets veranderen bij x bv., dat een tijdje later a gaat veranderen. y veranderen gaat een tijdje later b veranderen. Als a en b veranderd zijn, zal f een tijdje later veranderen. Wat je dan ziet verschijnen zijn vertragingen: het ogenblik dat de ingang verandert en dat de uitgang verandert, in elke re\"ele schakeling is dat zo. Die vertraging gaat meespelen in hoe effici\"ent de schakeling werkt. Het is dus belangrijk om die te kennen, je gaat dat nooit terugvinden in een logische functie, dat is bijkomende informatie. \\
Het tijdsgedrag nakijken is ook heel belangrijk om problemen te detecteren, problemen die je niet gaat zien als je alleen maar naar de functionaliteit gaat kijken. Bv. a en b veranderen ``tegelijkertijd" (dat bestaat niet! De ene gebeurtenis zal altijd iets voor de andere plaatsvinden.) $\rightarrow$ dat kan zijn gevolgen hebben: als b iets vroeger verandert dan a, dan krijgen we heel kortstondig een waarde 0, dan zie je aan de uitgang plots een piekje verschijnen, wat er niet zou mogen zijn. Als je gewoon naar de logica kijkt, zou die er niet mogen zijn, maar in praktijk is dat er wel en dit kan voor problemen zorgen. Dat piekje dat er is, dat we niet verwachten, kan opeens gevolgen hebben in de verdere verwerking van de schakeling, dus we moeten ons daar bewust van zijn. We moeten dus niet alleen de logische functies controleren, maar het tijdsgedrag is even belangrijk. 

\paragraph{Slide 16:} Kijken we dan naar het omgekeerde: we hebben een functionaliteit, hoe kunnen we dat implementeren? Er staan twee implementaties, als je die gaat uitrekenen, dan zie je dat die identiek zijn, die doen juist hetzelfde.\\
Als we dit gedaan hebben kunnen we kiezen voor een van de implementaties en vanuit logisch standpunt maakt het geen enkel verschil. Het is dan niet zo dat je eender welke realisatie zomaar mag kiezen: de linkse heeft meer poorten dan de rechtse: het gaat meer kosten (meer transistoren, een grotere chip,…). De linkse gaat ook trager werken want als je van x naar de uitgang moet ga je door twee ingangen telkens moeten gaan waar dat rechts niet het geval is.\\
Als we dan toch kunnen kiezen willen we het zo goedkoop mogelijk en zo snel mogelijk hebben. Hoe sneller die schakeling is, hoe hoger de verwerkingskracht: we kunnen maar aan de volgende bewerking beginnen als de vorige gedaan is. Als die schakeling dus heel snel een resultaat levert kan die heel snel aan een volgende bewerking beginnen. Vandaar dat hoe sneller de schakeling werkt, hoe hoger de verwerkingskracht. Als we dan toch kunnen kiezen willen we die schakeling met de minimale kostprijs en die schakeling met de hoogste verwerkingskracht (die zo snel mogelijk het resultaat geeft). We gaan daarvoor gebruik maken van de formules die erbij staan. \\
De snelheid is evenredig met het aantal ingangen, dus de linkse zal trager werken dan de rechtse. Op die manier kan men tussen de twee schakelingen kiezen en de beste kiezen.

\paragraph{Slide 18:} Boole algebra kan gebruikt worden omdat we ook hier met twee (logische) waarden werken. In de Boole algebra vertrekt men van een aantal axioma's. De duale uitdrukkingen zijn hier ook steeds geldig: je mag 0 door 1 vervangen en omgekeerd en + door . en omgekeerd.

\paragraph{Slide 20:} Wij gaan vooral gebruik maken van de wet van De Morgan: de inverse van het product is de som van de inversen en het inverse van de som is het product van de inversen. \\
In dit vak zal een distributiviteit voor de vermenigvuldiging ten opzichte van de optelling en distributiviteit van de optelling ten opzichte van de vermenigvuldiging gebruikt worden. 

\chapter{Les 2}
\section{Slides: 2\_Digitaal\_Ontwerp}

\paragraph{Slide 15:} Je wil weten wat de vertragingen zijn: het duurt een poosje als je iets aan de ingang verandert eer je het resultaat aan de uitgang ziet. Het tijdsgedrag toont ook problemen met de implementatie. Het probleem op de tekening toont dat a en b quasi gelijktijdig veranderen. Als a van 0 naar 1 gaat en b van 1 naar 0 zal de uitgang ook 1 worden dus f zou 1 moeten blijven. Het probleem ontstaat wanneer b iets vroeger verandert dan a: het uiteinde zal even 0 zijn, hoewel dat logisch gezien niet zou mogen. Op het moment dat je het ontwerp maakt is het belangrijk te weten wat zou kunnen optreden als probleem en je moet dat testen aan de hand van de re\"ele implementatie.

\paragraph{Slide 22:} Wij willen iets doen met de schakeling, hoe maak ik de schakeling zodat die daaraan voldoet? Er zijn 2 manieren om dat te benaderen: een schema tekenen/zoeken dat eraan voldoet. Anderszijds kan je ook een beschrijving in een taal doen.\\
Vandaag gaan we beiden ingeleid zien.

\paragraph{Slide 23:} Hoe best het gedrag beschrijven? $\rightarrow$ Aan de hand van een waarheidstabel. Het is nu de bedoeling om aan de hand van de waarheidstabel een implementatie te maken. De logische functie kun je ook altijd omzetten naar een waarheidstabel. Verschilllende logische functies kunnen eenzelfde waarheidstabel geven. De basisfucntionaliteit voor combinatorische schakelingen is dus de waarheidstabel.\\
In die waarheidstabel staat dat de uitgang 1 is als x en y 0 zijn,… \\
Je kan dit rechtstreeks implementeren met poorten: zie tekening rechtsonder.\\
Ofwel zijn beiden nul, ofwel is x 0 en y 1 ofwel zijn ze beiden 1 geeft f = 1. We kunnen van een beschrijving altijd rechtsreeks overgaan naar een implementatie. Probleem: we zijn niet ge\"interesseerd in \emph{een} implementatie maar in de beste, afhankelijk van de factoren die we belangrijk vinden. \\
Er zijn natuurlijk verschillende oplossingsmogelijkheden. Het komt er dus op neer om de beste te zoeken.

\paragraph{Slide 24:} Je kan daar naartoe werken door de bovenste uit te schrijven en dat eventueel te vereenvoudigen en daar wiskunding op te beginnen rekenen met de Boole-algebra. Het resultaat op deze slide getoond is veel eenvoudiger dan het voorgaande. Het gaat dus goedkoper zijn en een kleinere vertraging hebben en een kleiner vermogen verbruiken.\\
Hoe weet je nu dat je die regels moet toepassen? Niet: de prof wist wat hij moest vinden en heeft dan regels gebruikt om ertoe te komen. Je kan dus eindeloos vanalles proberen en als je dat op de zuiver wiskundige manier wil doen moet je heel veel proberen en dan de oplossing behouden tot je het beste resultaat bekomt. Je zou ook nog een regel kunnen toepassen die op zich een minder goede oplossing geeft. Het is dus heel moeilijk om te zien wanneer je moet stoppen met regels toe te passen. In CMOS is het tweede goedkoper dan het eerste: de technologie komt erbovenop om te weten wat het beste is.\\
Je hebt dus geen stappenplan/algoritme waarmee je er gegarandeerd komt. Hoe komen we dan tot een beter resultaat? $\rightarrow$ Gaan we later zien, in het volgende hoofdstuk: hoe kunnen we met een minimum aan uitproberen tot een goed resultaat komen?

\paragraph{Slide 25:} Je kan dat formuleren in functie van min- en maxtermen. Een minterm is een functie zoals beschreven op de slide die alleen waar is voor een van de rijen van de waarheidstabel. Je hebt hier 3 variabelen dus $2^3$ mogelijkheden. Hier staat geen functie of uitgang bij. Als je de functie erbij betrekt spreekt men over 1-minterm: de functie waarvoor de uitgang van de schakeling 1 is. In dit geval zijn dat er 4. 

\paragraph{Slide 26:} Je kan dat als volgt omschrijven: je kan altijd een implementatie van een schakeling doen door de som van zijn 1-mintermen te nemen. Dus voor elke rij hebben we een 1-minterm (?). Men noemt dit de canonieke som van producten oplossing $\rightarrow$ de voor de hand liggende oplossing, waar je niet over moet nadenken en je zo kan realiseren.\\
Het mooie aan Boole is dat de duale uitdrukking ook altijd geldig is. Dit kunnen we ook hier gaan toepassen.

\paragraph{Slide 27:} Maxterm = logische functie die 0 is voor 1 bepaalde rij van de kolom. Weerom kun je de functie er dan bij betrekken. Je krijgt hier geen 1-maxterm maar een 0-maxterm: maxterm waarvoor de functie 0 is en dus de rijen die er bij de 1-minterm niet bijzaten.

\paragraph{Slide 28:} Als je dit gaat combineren krijg je een product van sommen. Voor elke beschrijving die we hebben weet je dat er 2 implementaties zijn. Dat zijn 2 verschillende implementaties en we gaan sowieso meoten kiezen wat het beste is.

\paragraph{Slide 29:} Het probleem met de canieke: de duurste oplossing die er is (maar wel makkelijk op te schrijven): elke AND-poort heeft zoveel ingangen als er variabelen zijn. Een OR-poort heeft zoveel ingangen als at er rijen zijn waar een 1 in voorkwam op het einde. Dat is dus niet de compactste oplossing. We zijn op zoek naar eenzelfde manier van werken (SOP of POS) maar met poorten met minder ingangen die zo ook minder vermogen verbruiken. We gaan niet meer voor elke AND-poort alle ingangen proberen gebruiken en niet evenveel ingangen voor de OR-poort als in de waarheidstabellen.

\paragraph{Slide 30:} De twee canonieke vormen bovenaan. Als je daar een paar regels op toepast kan je beiden vereenvoudigen zoals onderaan getoond. Dit zijn de standaardvormen: die vorm die het minimum aantal poorten en de poorten met de minste ingangen gaat proberen te gebruiken. Als je de bovenste rijen daarmee vergelijkt bevat de bovenste elke term 3 ingangen vs. 2. Dat is al een winst in alle randvoorwaarden die we willen. Daarenboven hebben we vanboven 4 OR-poorten en vanonder maar 2. Ook dit is dus een duidelijke reductie in hardware.\\
We weten nu wel nog niet hoe we overgaan naar standaardvorm.

\paragraph{Slide 31:} We gaan dikwijls naar de SOP en POS-implementatie kijken omdat het zo is dat die standaardvorm eigenlijk de goedkoopste implementatie en dikwijls ook de snelste is, zeker wanneer je je beperkt tot 2 lagen. Een laag: bovenste tekening: een deel/laag AND-poorten en een laag OR-poorten (1 poort in dit geval). Die bepaalt de vertraging: je moet door 2 lagen om tot het einde te geraken. Hoe meer lagen, hoe trager het geheel gaat werken. We gaan dus proberen het aantal lagen te beperken. Het minimum dat we in normale omstandigheden nodig hebben zijn 2 lagen. Vandaar dat de getoonde tekening de snelste oplossing is.\\
We kunnen ook naar meer lagen gaan: onderste tekening. Hier gaat het duidelijk trager zijn: 3 lagen (dit was een examenvraag vorig jaar!). Soms is snelheid niet het belangrijkste: soms wil je een zo goedkoop/compact mogelijke implementatie en dan kan dit wel interessant zijn. Het onderste kan goedkoper zijn dan het bovenste: het verschil zit 'm in het feit dat er bovenaan een poort is met 3 ingangen en je die vanonder niet hebt. Als je dus niet in de snelheid ge\"interesseerd bent, kan de onderste dus beter zijn.\\
Wij gaan meestal met 2 lagen werken omdat dat evidenter is om toe te komen, 3 lagen is minder evident. 

\paragraph{Slide 32:} We gaan nu ook nog kijken naar NAND en NOR.

\paragraph{Slide 33:} We maken gebruik van 1 enkele soort poort. Dat is mogelijk door inverterende poorten zoals NAND of NOR-poorten te volgen. Het wordt als 1 poort beschouwd (de combinatie van AND en inverse of OR en inverse). In de CMOS-technologie is het makkelijker om een NAND-poort te maken dan een AND-poort: 
\begin{itemize}
\item Je moet een AND maken door een NAND te gebruiken en er nog een inverter achter te zetten.
\item Wanneer je NAND of NOR gebruikt moet je geen 3 basisschakelingen hebben, je hebt er maar 2 nodig. Schema onderaan: illustratie hoe je poorten kan maken met alleen NAND of alleen NOR. Denk tijdens het studeren na welk van de mogelijkehden het interssantst is om te gebruiken. 
\end{itemize}
Ook een NOR-poort kan je maken met een NAND-poort: de wetten van De Morgan: product van inversen is hetzelde als inverse van een som. Dat zie je in de omkaderde vakjes. Met een enkele basispoort kan je dus alles maken.\\
Het is nu wel zo dat de technieken die we later gaan zien altijd van deze basispoorten gebruik maken. Die gaan iets leveren dat bestaat uit AND en OR en invertoren. Er zijn geen specifieke technieken om alleen NAND of NOR te gebruiken. Op zich is dat geen probleem omdat een implementatie zoals op \textbf{Slide 34} kan omzetten naar alleen NAND of alleen NOR. 

\paragraph{Slide 34:} Maak gebruik van invertoren aan de uitgang en ingang. De drie schakelingen onder elkaar zijn dezelfde logische functies. Hetzelfde met iets alleen NOR-poorten.\\
Houd er rekening mee dat als je tot een implementatie met NAND-poorten wil komen je eerst een som van producten moet implementeren. 

\paragraph{Slide 35:} Als je gaat kijken naar de ontwerpmiddelen die bestaan, dan gaan die een ontwerp maken en die gaan je erbij helpen. Het grootste werk dat je zal hebben is het ingeven van het ontwerp hetzij via een schema, hetzij via VHDL. Daarna moet je doen wat we in de volgende hoofdstukken gaan bekijken. Die programma's zijn slim genoeg om alles te doen wat wij gaan zien, dus ze gaan in veel gevallen een automatische synthese doen. Op dat moment heb je een logische implementatie en kan je een functionele simulatie doen: testen of het doet wat het moet doen: als je een bepaalde combinatie van input geeft gaat het geven aan de uitgang wat het moet geven.\\
Het tijdsgedrag is even belangrijk, maar dat kan je op dit moment nog niet testen: je hebt alleen een logische beschrijving. Daarom komt er een stap achter: je moet ook het fysische ontwerp doen en nagaan wat het tijdsgedrag en de elektrische eigenschappen etc. zijn. Je moet een prototype bouwen en daarop metingen uitvoeren. Wanneer dat tot een ge\"integreerde schakeling moet leiden is dat een verspilling van tijd en kosten dus normaal gaat de fabrikant van die ge\"integreerde schakeling weten wat de eigenschappen gaan zijn van die componenten. $\rightarrow$ Al die details zijn gekend. Die zal een module aanbieden waarin alle gegevens verwerkt zijn en het fysische ontwerp nabootst. Op die manier kan je metingen doen qua tijd etc. Je kan ook naar alle problemen zoals glitches gaan zoeken. Pas dan ga je de finale stappen uitvoeren: implementeren of de chip laten maken. 

\paragraph{Slide 37:} Andere manier om hardware te omschrijven: hardware-omschrijvingstaal. Wij gaan kijken naar VHDL. Dat is ontstaan uit subsidies van het Amerikaanse ministerie van defensie. De bedoeling was dat men een methode wou hebben om heel complexe ontwerpen te beschrijven en alle gegevens erbij te zetten, alle info om te simuleren en beschrijven en dat systeem op een voldoende hoog niveua te beschrijven.\\
De taal moet in staat zijn om gelijk welk digtaal systeem te beschrijven en alle aspecten ervan. Het moet het dus volledig kunnen specifi\"eren. Dus niet alleen op poortniveau maar ook op hogere niveau's. Je begint dus op een hoog niveau en je daalt af. De bedoeling is hier dat je het systeem op alle niveau's kan beschrijven:
\begin{itemize}
\item Op het hoogst niveau heb je een beschrijving van het gedrag: ``Dit blokje moet dat doen" . 
\item Je moet ook kunnen testen dus tijdsparameters erin beschrijven. Simulatie moet hier dus ook mogelijk zijn. 
\item Men zou ook graag hebben dat er een automatische synthese is: dat je je geen zorgen moet maken om de tussenstappen. 
\item Ook documentatie is belangrijk. 
\end{itemize}
Het is ook belangrijk dat het gestandaardiseerd is. Dat zorgt ervoor dat verschillende fabrikanten die ieder hun eigen implementaties doen mekaar altijd verstaan: er kan geen verkeerde implementatie mogelijk zijn want in de taal is de implementatie exact beschreven. Nadeel: als er nieuwe idee\"en komen/er zijn tekorten, dan kan men het niet meer veranderen $\rightarrow$ nieuwe versie van de taal/software nodig.

\paragraph{Slide 38:} VHDL is voor digitale systemen, maar een systeem bestaat meestal uit digitale en analoge componenten. Men heeft het systeem dus uitgebreid naar het combineren met analoge signalen. Om een analoge schakeling op te lossen heb je 200-300 gekoppelde differentiaalvergelijkingen nodig om tot uw oplossing te komen. 

\paragraph{Slide 39:} Andere kandidaat die minstens evenwaardig is: Verilog. Wordt meer gebruikt in de VS. VHDL is populairder in Europa. De concepten die erachter zitten zijn speciaal: hardware beschrijven is niet hetzelfde als een programma schrijven. Er zitten dus speciale concepten achter die je moet begrijpen voor beide talen, alleen de syntax verschilt. 

\paragraph{Slide 40:} Wat is nu het interessantste: schema of hardwaretaal? $\rightarrow$ Hangt af wat je ermee moet doen. Schema's zijn interssant voor kleine ontwerpen, VHDL is gewoonlijk interessanter wanneer het over grotere ontwerpen gaat.
Nadelen van VHDL t.o.v. schema's: 
\begin{itemize}
\item De concepten achter VHDL zijn niet voor de hand liggend en je hebt dus enige tijd nodig om dat te leren beheersen. 
\item Het is nogal langdradig: om de kleinste component te beschrijven heb je onmiddelijk veel lijnen code nodig. Dit maakt dat het voor mensen moeilijk is om te begrijpen wat er allemaal gebeurt. Een schema is visueler en daarin zijn mensen getrainder.
\item VHDL bevat alle mogelijkheden: alle mogelijkehden voor simulaties, maar om te begrijpen wat het doet, om alleen de functionaliteit te kennen heb je dat allemaal niet nodig.
\end{itemize}

\paragraph{Slide 41:} Voordelen van VHDL t.o.v. schema's:
\begin{itemize} 
\item Het is een standaard: je kan het gebruiken om informatie uit te wisselen tussen programma's/tools van verschillende fabrikanten. Het is dus makkelijk overdraagbaar.
\item VHDL is goed in alles waar programma's goed in zijn. Wanneer je repetitieve structuren hebben (een aantal cores die allemaal hetzelfde zijn), dat is 1 instructie in VHDL. Als je een schema tekent, moet je dat zoveel keer tekenen. In een programma kan je ook parameters gebruiken. Als je een schema tekent moet je het helemaal uitgommen en opnieuw beginnen indien een parameter verandert. In een programma, als uw parameter bv. niet voldoende groot is, pas je dat gewoon aan.
\item In een schema moet je onmiddelijk componenten kiezen om erop te zetten. VHDL heeft het voordeel dat je het gedrag kunt beschrijven, je moet dus niet per s\'e een implementatie kiezen.
\end{itemize}

\paragraph{Slide 42:} Beperkingen:
\begin{itemize}
\item VHDL heeft zoveel mogelijkheden dat het enorm veel inspanning vraagt van de fabrikanten om alle aspecten uit de taal om te zetten naar hardware. Men heeft zich dus beperkt tot een subset die makkelijker om te zetten is in hardware. Wanneer je gaat synthetiseren ga je je dus moeten beperken.
\item Van een hardwarecompiler verwachten we een enorme intelligentie. In vele gevallen zijn er een tiental mogelijkheden om een implementatie te realiseren. De compiler moet dus raden wat je bedoelt wat je neerschrijft. In de meeste gevallen raadt hij dat zo strict mogelijk. Je moet in de meeste gevallen de compiler dus wat helpen. Je moet ongeveer weten hoe hij interpreteert wat jij hebt neergeschreven. Je moet je dus aanpassen naar de mogelijkheden van de compiler. De hardware die uit een ontwerp van een beginneling komt zal minder optimaal zijn dan die an een meer ervaren ontwerper.
\end{itemize}

\paragraph{Slide 43:} Schema tekenen: kan in een keer, maar in de praktijk ga je op de hi\"erarchische manier werken. Je gebruikt blokjes die je eventueel nog niet defini\"eert en waarvan je later de ontbrekende blokjes gaat specifi\"eren. Je kan het als een doos bekijken met een aantal in- en uitgangen. Die hebben een aantal karakteristieken en wat er in die doos inzit. Wat zit er in die doos? De bewerkingen die we moeten doen. Stel dat we een component hebben die test of 2 getallen aan elkaar gelijk zijn. In die doos zitten dus componenten en die leveren resultaten af. We hebben ook verbindingen nodig.\\
We kunnen dit nog niet implementeren omdat we nog niet hebben aangegeven wat de component is. We hebben wel al aangegeven dat het twee keer hetzelfde is. Die component moeten we nu maar 1 keer ontwerpen en die kunnen we 2 keer gebruiken.\\
Nu de rechtse doos: op een lager niveau specifi\"eren. We kiezen een mogelijke implementatie. Die twee stukken kunnen door 2 verschillende personen gemaakt worden. Men kan eerst het rechtse maken en dan het linkse. In veel gevallen is het rechtse beschikbaar in een bibliotheek.\\
Wanneer je met VHDL werkt, gaat dat eignelijk juist hetzelfde zijn.

\paragraph{Slide 44:} 2 stukken: entiteit die de doos beschrijft. We hebben een comparator comp die twee ingangen heeft: 2 ingangen en 1 uitgang en de ingangen zijn 8 bit en de uitgang 1 bit.\\
Daaronder staat de architectuur: wat er in de doos zit, wat we daarnet in de doos tekenden.\\
Het verschil met het schema is dat we nu ook het gedrag kunnen beschrijven zoals gedaan is op de slide: we kunnen schrijven wat de comparator doet. Er staat niet geschreven hoe dit ge\"implementeeerd moet worden, er is gewoon beschreven wat het doet. \\
Het is ook zo dat voor een bepaalde component er verschillende implementaties kunnen zijn: gedrag beschrijven, implementatie beschrijven, voor sommige theorie\"en zal iets goed zijn, in anderen niet. De architecturen krijgen daarom een naam omdat je zo kan kiezen voor een bepaalde implementatie.

\paragraph{Slide 45:} Kijken we naar het topschema beschreven via de structuur. Een structurele beschrijving is juist hetzelfde als het schema tekenen. Entity Test is weer de doos en de architecture is weer de beschrijving hoe het ge\"implementeerd is. We hebben een component Comparator nodig, dat is een virtuele component en we moeten die nog niet meteen beschrijven, gewoon de in- en uitgangen.\\
Bij begin staat er dat je die twee keer gebruikt. Je kan die verschillende namen geven (Comp1 en Comp2) om een onderscheid te kunnen maken. Rechts worden de draden beschreven. \\
Dit is in woorden neergeschreven wat rechts vanboven met een schema staat. \\
Belangrijk is om in gedachten te houden dat het een beschrijving van hardware is. De volgorde van instructies is hier niet belangrijk omdat het over hardware gaat. Het in een andere volgorde zetten gaat hetzelfde eindresultaat geven: de uiteindelijke manier van werken blijft hetzelfde. Ook de volgorde van de uitdrukkingen doet er dus niet toe: parallele uitdrukkingen. De volgorde is totaal onbelangrijk.

\paragraph{Slide 46:} Hoe leg je het verband tussen de twee schema's/beschrijvingen? Dat gebeurt heel expliciet: VHDL is een heel stricte taal dus normaal moet je alles heel uitgebreid beschrijven, maar als je uw namen goed schrijft kan hij raden wat je bedoelt. Als de specificaties overeenkomen (naam Comparator met x ingangen en y uitgangen) dan zal die dat kunnen raden. Je kan ook een specifieke mapping maken: we gebruiken de component Comp met architectuur Behav1: we kiezen meteen een specifieke implementatie. Mapping: in het ene geval hebben we X,Y,Z gekozen, in het andere A,B,EQ. je kan dus heel specifiek aangeven hoe je de schema's met elkaar verbindt.

\paragraph{Slide 47:} VHDL verchilt vrij hard van een gewone programmeertaal, het ziet er alleen uit als een programmeertaal. Vanboven: ``gewone" programmeertaal: functie die je defini\"eert. In VHDL beschrijf je gedrag. Het topniveau is het hoofdprogramma: main() die de functie 2 keer gaat gebruiken. Belangrijk verschil: bij het vorige waren de uitdrukkingen parallel, hier sequenti\"eel: het ene wordt uitgevoerd na het andere, er is een stricte volgorde en dat kan zijn impact hebben. Bij hardware is dat niet zo: het is niet zo dat de bovenste component eerst werkt en dan de onderste. \\
Nog een verschil: een softwareprogramma start je op, die voert het programma uit en aan het einde van het programma stopt het. Bij hardware is het juist omgekeerd: hardware stopt niet. Hardware begint te werken zodra je de spanning opzet en die blijft eindeloos altijd maar hetzelfde doen tot je de spanning afzet. Dat is de enige manier om die tot stilstand te brengen. Software: er is een bug aanwezig als het blijft runnen, hardware: er is een bug aanwezig als het stopt.

\paragraph{Slide 48:}
\begin{itemize} 
\item Datatypes: als je een computer gebruikt met bv. 32 bits of 64 en je wilt 2 8-bits optellen, zal dat toch een 32 of 64-bitoptelling zijn. Bij hardware is dat niet zo. Bij hardware ga je niet nodeloos bits gebruiken: als je het met 4 bits kan doen ga je dat doen. Je gaat altijd het minimaal aantal bits gebruiken omdat dat het goedkoopste is en de compactste oplossing is. In VHDL moet je dat daarom ook specifi\"eren: gaat erin als 5 bit en komt eruit als 7 bits.
\item Gelijktijdigheid: hardware werkt altijd gelijktijdig, niet de ene na de andere.
\item Tijdsconcept: componenten werken continu, hardware stopt nooit. Qua tijdsconcept er ook rekening mee houden: de simulatie is niet de re\"ele tijd. Het kan zijn dat je een minuut moet rekenen om de simulatie 1 nanoseconde vooruit te laten gaan.
\end{itemize}
	
\section{Sides: 3\_Technologie}

\paragraph{Slide 3:} Als we elektronische schakelingen willen implementeren, hoe gebeurt dat in de praktijk? Het eerste wat we moeten beslissen is welke fysische waarden we hebben. Als je een logische schakeling maakt, moet je een fysische waarde hebben. We gaan dat doen met fysische bereiken: als de blauwe pijl de spanning voorstelt; L is een lage waarde, H is een hoge waarde. Die twee bereiken raken elkaar niet: daartussen is een stuk waar het noch hoog, noch laag is: ongedefini\"eerd.\\
Waarom bereiken? We willen onze schakeling zo robuust mogelijk. We willen niet dat we de schakeling zo nauwkeurig moeten maken zodanig dat er schakelingen nodig zijn waar exact 3V uitkomt en niet 3.1V bv. Als je toelaat dat het 3V, 3.5V of 2.5V kan zijn, laat je veel meer variatie toe. Verschillende componenten hebben allemaal verschillende karakteristieken, er zijn fluctuaties. Het feit van een bereik te gebruiken laat fluctuaties toe. Op die manier kunnen we dat oplossen en kunnen we veel makklijker ingewikkelde zaken maken, dat hebben we ook als we verschillende transistoren op 1 component willen zetten.\\
Ook het gebruik be\"invloedt dit: elektronica is heel gevoelig aan temperatuur: enorm groot verschil of de schakeling werkt aan 20 graden Celcius of 40 graden Celcius. Hou er rekening mee dat de schakeling zelf ook opwarmt. Je wil dat uw schakeling blijft werken. \\
Ook de spanning is niet altijd juist dezelfde.\\
Waarom 2 bits: om het systeem minder gevoelig te maken. Hoe meer mogelijke waarden, hoe kleiner de bereiken zijn.\\
We hebben het nog niet over 0 of 1 gehad. Het hoeft niet per s\'e zo te zijn dat 0 laag is en 1 hoog $\rightarrow$ positieve logica, maar je kan ook negatieve logica hebben waarbij men het omgekeerd doet (0 is hoog en 1 is laag).

\paragraph{Slide 4:} Hoe die poorten maken? Los van de elektronica: we kunnen dat maken als we beschikken over schakelaars die we kunnen aansturen. We hebben een schakelaar die 2 standen heeft: open of gesloten. We moeten die kunnen aansturen. $\rightarrow$ 2 soorten schakelaars.

\paragraph{Slide 5:} NMOS-transistor: poort ge\"isoleerd van het blokje p. Als de spanning klein is zal er niks gebeuren en zal de halfgeleider zich gedragen als een isolator. Wordt de spanning voldoende groot, zal die elektronen aantrekken om een geleidend pad te cre\"eren en wordt er een verbinding gemaakt. Op die manier kunnen we die gebruiken als schakelaar.\\
PMOS: hetzelfde prentje waar de p en de n verwisseld zijn en de source en de drain verplaatst zijn. Dat zal ervoor zorgen dat de gesloten schakelaar lage spanning betekent: de negatieve spanning is heel groot. \\
Op die manier kunnen we die 2 soorten schakelaars maken. We krijgen dit op dezelfde ge\"integreerde schakeling.

\paragraph{Slide 7:} Er poorten mee maken. 
\begin{enumerate}
\item Enkel gebruik maken van NMOS. Dan krijg je een schakeling zoals op de afbeelding. Stel dat er aan x een lage spanning is, dan zal de transistor (rood) niet geleiden. De uitgang zal via de weerstand verbonden zijn met de voedingsspanning. Als er geen (grote) stromen staan, dan zal de spanning ongeveer gelijk zijn aan de bronspanning. Als er een hoge spanning op zit zal de transistor een lage weerstand hebben (veel lager dan eerst) met als gevolg dat die de uitgangsspanning naar beneden trekt: de weerstand is niet krachtig genoeg om het tegen te houden.  Daarom komt er een laag niveau op te staan. Als je dit met positieve logica doet, dan hebben we een invertor gebouwd. Dit is tegenwoordig niet de manier die meestal gebruikt wordt omdat er belangrijke nadelen zijn: 
\begin{enumerate}
\item De weerstand zal nooit helemaal nul zijn. Je krijgt een spanningsdeling over de twee weerstanden. Dat is geen probleem als het maar laag genoeg is, maar het gaat niet echt nul zijn. Dat betekent dat de bovenste weerstand beduidend groter moet zijn want anders krijg je het omgekeerde.
\item Dit soort schakeling heeft een statisch vermogenverbruik: we verbruiken ook vermogen op het moment dat er geen veranderingen optreden: alles is constant en toch blijven we vermogen verbruiken. Als er een geleiding is, loopt er een stroom van boven naar beneden. Een stroom door een weerstand betekent vermogenverlies. We kunnen dat alleen maar klein houden als die R zeer hoog is. In het realistische voorbeeld zal het toch 1mW verbruiken, maar een schakeling bestaat niet uit maar 1 inverter/transistor, er zal dus een enorm hoog vermogenverbruik zijn. 
\end{enumerate}
Het wordt niet meer gebruikt behalve bij open-drain.
\end{enumerate}

\paragraph{Slide 8:} De weerstand wordt buiten de verpakking weergegeven (stippellijn). Als de schakeling nog niet gemaakt is, hangt die draad los dus vandaar een open drain. Wat is er hier specifiek aan? Als je 1 inverter hebt: niks. Als je er meerdere hebt en je hangt de uitgangen aan elkaar, dan krijg je bv. de gegeven waarheidstabel. We hebben zo een NOR-poort gemaakt. We noemen dit een wired-AND functionaliteit: we hadden oorspronkelijk 2 op zichzelf staande invertoren. We hebben die uitgangen aan elkaar gehangen en zo een NOR gemaakt. Die NOR kan ook op rechtsonderstaande manier omschreven worden. In het logische schema zit ook een AND-poort. Dit komt omdat de twee uitgangen aan elkaar hangen. Door een bedrading aan te leggen is er een extra functionaliteit. Het nadeel is dat je met NMOS blijft werken en het statisch vermogenverbruik hebt.

\paragraph{Slide 9:} Lichtschakelaars in serie of parallel zetten. Als we hier 2 transistoren in serie zetten krijgen we wat op de slide staat. We hebben hier een NAND-poort gemaakt. We kunnen dat ook in parallel zetten, we krijgen dan een NOR: zodra 1 van de twee 1 wordt, wordt de stroom weggeleid.

\paragraph{Slide 10:} Stel dat we het statisch vermogenverbruik willen vermijden. Dit kan door te zorgen dat er nooit een geleidend pad is. Dit kan door 2 transistoren te voorzien: 1 boven- en 1 onderaan. Vanboven een PMOS en het ander een NMOS. Het een is een pull up, het ander een pull-down. Hier hebben we geen statisch vermogengebruik want in geen van de twee gevallen is er een geleidend pad van de bron naar onder want in elk geval zal een van de twee open zijn.

\paragraph{Slide 11:} Je mag dit nooit met CMOS doen: die werkt aleen als PUN en PDN complementair zijn: als ze alletwee beginnen geleiden, dan loopt er een stroom die bepaald wordt door de weerstand van een transistor die geleid, wat een zeer lage weerstand is, er zal dus een enorm grote stroom doorlopen. Gevolg: uw schakeling ontploft (wordt getoond in de slides normaal gezien). Je moet dus altijd zorgen dat de twee nooit gelijktijdig geleiden.\\
Als je de uitgangen aan elkaar hangt kan je dit ook krijgen: ook een grote stroom en minstens een van de twee zal kapot gaan.\\ 
CMOS-uitgangen mag je dus nooit zomaar aan elkaar hangen! 

\paragraph{Slide 12:} Als we ze toch aan elkaar moeten hangen, gaan we een speciale oplossing moeten gebruiken.  We hebben een inverter gemaakt en een serie- en parallelschakeling. Op deze manier kunen ze nooit gelijktijdig geleiden. Het bovenste PUN is altijd complementair aan het PDN. Ook hier is een NAND-poort gemaakt. Je kan dit ook omkeren: boven serie en vanonder de parallel. Dat leidt tot een NOR-poort. Ook hier zijn de basiscomponenten een NAND en NOR  poort.\\
Interessant hier is dat we daarnet 2 ingangen hadden en 2 transistoren. Hier 2 ingangen en 4 transistoren: per ingang 2 transistoren erbij, dit blijft gelden: per ingang die erbij komt hebben we 2 transistoren nodig. Daaruit volgt dat de kostprijs van een poort bij CMOS evenredig is met het aantal ingangen.

\paragraph{Slide 13:} Negatieve logica en actief lage signalen.

\chapter{Les 3}

\section{Sides: 3\_Technologie}

\paragraph{Slide 13:} Negatieve logica en actief lage signalen hebben strikt gezien niets met elkaar te maken. Het lage bereik komt overeen met een 1 (negatieve logica).

\paragraph{Slide 14:} Impact op de implementatie: die implementatie geeft een NAND-poort. De onderste waarheidstabel hoort daar dus bij en niet de rechtsbovenste. De vertaling van een L naar een nul is positieve logica. Werk je met negatieve logica is het natuurlijk omgekeerd. Je krijgt dan een NOR-poort. In de praktijk werken we omgekeerd: we maken een schema en afhankelijk van de technologie kiezen we voor positieve of negatieve logica. Kiezen we voor positieve logica, dan zal het de afgebeelde afbeelding zijn, anders zal het een andere implementatie zijn.\\
In sommige schema's zie je een klein driehoekje staan: geeft aan dat die draad met negatieve logica werkt. In de praktijk ga je dat vrijwel nooit terugvinden: ofwel werk je met positieve ofwel met negatieve logica. Het is pas wanneer je gaat mengen dat je die driehoekjes nodig hebt.

\paragraph{Slide 15:} Actief lage signalen: heeft niks met het lage en het hoge te maken, het actief zijn heeft enkel te maken met de interpretatie, niet met het binair signaal dat erop staat. \\
Voorbeeld: wanneer je een reset-signaal hebt (om een systeem in een initi\"ele toestand te brengen: als je de spanning opzet, komt uw systeem in een random toestand. In praktijk wordt de spanning opgezet en onmiddelijk een reset aangebracht om het toestel in een gekende toestand te brengen). Het resetten van een toestand is een activiteit, je moet dat doen. Iets doen kan met een signaal dat 0 of 1 is. Het is niet de logische spanning die op de lijnen staat, maar wanneer iets wordt gedaan: wanneer het een 0 is wat erop staat of wanneer het een 1 is wat erop staat. Dat heeft dezelfde notatie als het inverse, maar daar heeft het dus niets mee te maken. Wij gaan inverse aangeven met ' en actief signaal met *. Als het signaal 0 is, zal de schakeling op de slide gereset worden.\\
Als je poorten/logische functies gaat bekijken treedt hier voor het eerst het verschil op tussen de poort en de functionaliteit. De functionaliteit beschrijft wat er moet gebeuren in welke omstandigheden (bv. uitgang zal actief zijn bij AND als  beide signalen actief zijn). Bekijken we nu de waarheidstabel op de slide verwachten we normaal een AND-functionaliteit, dat is er een voor actief hoge signalen. Als ``er gebeurt iets" overeenkomt met een 0, dan is de waarheidstabel een OR-functionaliteit. Dat is en blijft een AND-poort en de positieve of negatieve logica staat hier totaal los van. De interpretatie van ``er gebeurt iets" verandert afhankelijk van of het actief hoge of actief lage signalen zijn. Meestal wordt er gekozen om met actief hoge signalen te werken, dat vereenvoudigt de interpretatie. \\
Toch zijn er veel plaatsen met actief lage signalen. Er zijn typisch 2 plaatsen waar je het frequent tegenkomt: reset en bij afgesloten verbindingen. Wired OR = wired AND (want je kan geen wired OR maken op zich) met actief lage signalen waardoor die AND poort voor een OR-functionaliteit gebruikt kan worden. 

\paragraph{Slide 16:} Bedoeling: OR-functionaliteit nodig en die met wired AND organiseren, of ook: met een schakeling vanonder getoond: met RC-schakeling. De schakeling wordt opgezet en de spanning gaat blijven stijgen. In dat eerste deel kan je niks zeggen over de schakeling, daar gebeurt de rommel, je weet niet wat er gebeurt. Een keer die in werkende toestand is, kan je die resetten. De capaciteit gaat proberen de spanning laag te houden en via de weerstand gaat het opgebouwd worden. Die ingang van de schakeling RST (groene lijn op de grafiek) gaat langzaamaan opbouwen. De spanning bij RST* gaat dus vrij lang laag gehouden worden. Om dat soort zaken te doen moet het een actief laag signaal kunnen zijn. \\
Je wil een RST-knop hebben waar je op drukt en dan moet dat in orde zijn. Het is makkelijker om het met een wired-AND te doen dan met poorten. Het grote voordeel daarvan is dat je dat eindeloos kan uitbreiden: gewoon een draad erbij leggen, geen poort vervangen ofzo. \\
In de meeste schakelingen is de RST een actief laag signaal.

\paragraph{Slide 17:} Tweede reden waarom er actief lage signalen gebruikt worden: wanneer dingen afgesloten zijn, zit je meestal in een hogere teostand. Op de slide getoond: langere lijnen, maar het hangt af van de frequenties waar je mee werkt.\\
Verbinding: spanning aan de ene kant en verwachten die onmiddelijk aan de andere kant te zien. Bij een transmissielijn plant die overgang zich voort over de lijn en dat duurt een zekere tijd eer die de andere kant bereikt. Dan gaat niet alleen de spanning verhogen aan de andere kant maar eventueel slechts een deel van de energie opgenomen worden door degene die de spanning al dan niet meet en een deel gaat teruggekaatst worden, het zal daar ook gedeeltelijk geabsorbeerd worden en gedeeltelijk teruggekaatst worden.\\
Wat als je dat op een oscilloscoop bekijkt? Het rechtse signaal. Hoe meer reflecties er heen en weer gaan, hoe groter de overshoots zijn. Wat we eigenlijk willen is het linkse: je gaat naar een ander niveau en blijft daar. Dat kan je bereiken bij een transmissielijn door ervoor te zorgen dat degene die het signaal moet opnemen dezelfde impedantie heeft als de draden. Het komt erop neer dat je die draden moet afsluiten op de karakteristieke impedantie. Die kan soms redelijk laag zijn. \\
Hoe sluit je dat af? Zoals linksonder getoond: aan de ontvangstzijde 2 weerstanden zetten die ervoor zorgen dat de karakteristieke impedantie gelijk is aan de parallelschakeling van die 2 weerstanden. Welke spanning er op de draad hangt wordt bepaald door de twee weerstanden. Als je uw spanning aanzet zal er 5V opstaan. Als die draad niet aangestuurd wordt, als daar niets mee gebeurt, dan staat daar een 1 op. Dat betekent dat we met actief lage signalen moeten werken: we doen niks en er staat een 1 op.\\
Vandaar, bij plusverbindingen (die tekening) ga je het regelmatig tegenkomen dat er ook daar met actief lage signalen gewerkt wordt. 

\paragraph{Slide 19:} Meer complexe schakelingen maken: bij CMOS moet je ervoor zorgen dat als de bovenste geleidt, de onderste niet mag geleiden en omgekeerd. Je kan ook heel wat andere combinaties van transistoren maken.\\
Het makkelijkste is te kijken wanneer de onderste tak gaat geleiden: wanneer a \& b 1 zijn of wanneeer x, y, z 1 zijn, dan zal het signaal nul zijn.\\
Dit is 1 enkele poort die iets meer doet dan alleen maar AND of OR implementeren: AOI. \\
Vanonder altijd NMOS, vanboven altijd PMOS. \\
Het aantal transistoren dat je nodig hebt is twee keer zo groot als het aantal ingangen. De kostprijs van de schakeling is evenredig met het aantal ingangen. Let wel: ook hier gaat het over inverterende poorten. De uitgangen van de twee ANDS of de twee ORS tellen niet mee als ingang! 

\paragraph{Slide 20:} Er zijn een aantal dingen die je niet kan maken met 1 enkele poort: je moet een NAND-poort maken gevolgd door een invertor $\rightarrow$ impact op kostprijs en vertraging.\\
Buffer: doet op zichzelf niks, maar je kan meer aansturen.\\
Als je naar een XOR-poort gaat kijken: die gaat 1 zijn als ingang 1 of 2 1 is maar niet als ze alletwee 1 zijn. XNOR zal 1 zijn als beide ingangen 1 of 0 zijn. Hoe maak je dat? Met AND en OR-poorten, maar het kan effici\"enter zoals in het blauw: dat is een OR-AND-inverter. Voordeel: bij gewone poorten heb je er 3 nodig met ieder en kostprijs, bij OAI heb je 1 poort nodig en 2 invertoren.

\paragraph{Slide 21:} Mogelijkheid: uitgang is zwevend/open/nergens aan verbonden. Zwevende draden zorgen voor problemen dus wil je niet. Omdat ze door niets aangestuurd worden, is er niets dat ervoor zorgt dat die 0 of 1 blijven. Normaal staat daar geen spanning op, maar die reageren als antenne: je steekt de verlichting bv. aan en door inductie verandert de spanning op die draad. Loshangende draden wil je dus niet. \\
Waarom wil je dat toch kunnen doen (die aan niks laten hangen)? We hebben het al over wired-AND gehad, bij CMOS mag je de uitgangen nooit aan elkaar hangen, maar wat als je de ingangen aan elkaar wilt hangen? De enige oplossing om uitgangen bij CMOS aan elkaar te hangen is door gebruik te maken van een tristate buffer: geeft ingang door aan uitgang zonder functionaliteit, maar die kan de uitgang loskoppelen.\\
Hoe kan je dat implementeren? Met de getoonde schakeling: geen van beide zal geleidend zijn en dus losgekoppeld van de rest van de schakeling.
%TODO nagaan of mijn "denk ik" klopt.
\paragraph{Slide 22:} Bij een normale aansturing heb je 1 element dat aanstuurt en je op de meeste plaatsen gebruikt (denk ik). Als je een bus-verbinding hebt (kan vanop verschillende plaatsen aangestuurd worden, wel van 1 plaats tegelijkertijd), moet je die vanaf 2 kanten kunnen aansturen, nooit tegelijkertijd (want dan heb je uitgangen die aan elkaar hangen!). Als je nu een intelligente sturing hebt die ervoor zorgt dat maximaal 1 of 2 verbonden kan zijn met de bus, dan kan dat wel op die manier. Je kan uitgangen van CMOS aan elkaar hangen als je gebruik maakt van een tristate buffer en die op een intelligente manier aanstuurt. 

\paragraph{Slide 23:} Praktische aspecten: wat voor soort transistoren we gebruiken,\ldots $\rightarrow$ heeft impact op de karakteristieken van de schakeling (vooral op het tijdsgedrag, niet zozeer op de logische functie). 

\paragraph{Slide 24:} Gevoeligheid voor storingen: men zorgt er altijd voor dat er een ruismarge is: we hebben een hoog bereik en een laag bereik. Normaal verwacht je dat als een poort iets aanstuurt, de uitgang van de poort die aanstuurt moet hetzelfde bereik gebruiken als de poort die zijn uitgang moet bekijken. Die kan dus geen groter bereik hebben bij het produceren van de spanning dan wat gespecifi\"eerd is. Je kan wel een kleiner bereik hebben. Eigenlijk heb je dus een stuk niet nodig: het groene stuk. Het is toch nuttig om het verschil te maken want dat is de ruismarge. Waarvoor gaan we de gebruiken? Stel dat je een spanning genereert aan de uitgang die verbonden wordt aan de ingang van de volgende. Op die draad ontstaan storingen. De spanning die de andere poort aan de ingang ziet kan hoger/lager zijn dan die gegenereerd door de eerste poort. Wanneer dat naar boven gaat is dat niet erg, maar als dat te laag gaat kan de ontvangende poort dat niet meer correct interpreteren. Die ruismarge dient dus om storing op te vangen. Daardoor wordt uw schakeling minder gevoelig voor storingen. Bij CMOS: hoogbereik: tussen 3.5 en 5V. Je hebt 0.9V ruismarge want de meesten gaan tussen 4.4 en 5V genereren.
Bij CMOS is dat mooi symmetrisch maar dat hoeft niet zo te zijn. Bij TTL (transistor transistor logic) is dat niet symmetrisch. 

\paragraph{Slide 25:} Niet-ideale gedrag van de schakeling: als je een inverter bekijkt en je gaat naar de spanningen kijken. Horizontaal: ingangsspanning, verticaal: uitgangsspanning. L = laag bereik aan in- en uitgang, H = hoog bereik aan in- en uitgang. Wat in het groen aangegeven is is de normale werking: als er een hoog signaal aan de ingang is, zal er een laag signaal aan de uitgang zijn. Als we schakelen (overgaan van 0 naar 1 of omgekeerd) moeten we overgaan van het ene groene stuk naar het andere. We noemden het stuk ertussen ongedefini\"eerd, maar die zijn niet ongedefini\"eerd, die spanningen. De spanning zal niet met een 0 overeenkomen, ook niet met 1, ook niet met tristate, dat heeft logisch gezien geen enkele betekenis. Als je $V_T$ aanlegt weet je totaal niet wat uw spanning gaat doen, ze gaat in elk geval niet meer digitaal werken, het zal zich analoog gedragen: als een versterker: kleine veranderingen aan de ingang hebben een grote uitgang. Het ideale zou zijn als we geen curve hebben zoals getoond, liever zouden we iets ideaal hebben: hoog tot aan de drempelspanning ($V_T$, wanneer schakelen we over van laag naar hoog). Zodra we over die drempelspanning zijn, zullen we van laag naar hoog gaan. In het tussengebied is de uitgang ook niet gedefini\"eerd. Het probleem van in het ongedefini\"eerde gebied te zitten: de schakeling werkt daar niet op een digitale manier en we kunnen niet voorspellen wat de schakeling daar doet. We moeten daar aan heel hoge snelheid doorgaan: we hebben even een probleem, maar we zijn er onmiddelijk voorbij. We weten dat er bij elke overgang heel even in het gebied gezeten zal worden.\\
Een ander probleem is dat als je kijkt naar CMOS: dynamisch vermogenverbruik: bij tussenin zal niet 1 van de schakelaars open/gesloten zal zijn, ze zullen alletwee een beetje openstaan en er beiden een beetje tussenin zitten: gaat door alle tussenliggende waarden. Dat is het moment dat zowel de bovenste als onderste tak kunnen geleiden, waarbij je vermogenverbruik krijgt.  Dus in het rode gedeelte ga je ook bij CMOS vermogenverbuik hebben. Je hebt dit vermogenverbruik ook alleen wanneer je een overgang maakt van de ene naar de andere toestand (vandaar dynamisch). Die curves zijn ook niet constant, die kunnen vari\"eren omwille van het productieproces maar ook door temperatuursvariaties. 

\paragraph{Slide 26:} Het is belangrijk om zo snel mogelijk door dat gebied te gaan. Normaal zorgen we ervoor dat aan de ingang die signalen redelijk snel veranderen, dus we gaan daar maar korte tijd inzitten, in die overgang. Jammer genoeg hebben we dat niet altijd in de hand. Als je het signaal opmeet dat van de buitenwereld komt (je hebt een sensor die iets meet en de snelheid waaraan dat verandert wordt door de omgeving bepaald), dan bepaal je dat niet zelf. Het kan dus zeker zijn dat je traag vari\"erende signalen hebt aan de ingang. Dat soort signalen heeft ook typisch wat ruis/verstoringen. Dat gaat niet mooi van laag daar hoog, daar zit variatie op. Als je het re\"ele signaal in een digitale schakeling binnenbrengt en je steekt dat in een inverter, dan krijg je de tweede bovenste grafiek (de middelste). Rond die drempelspanning zal dat werken als een versterker en kleine veranderingen aan de ingang worden grote veranderingen aan de uitgang. Als je dat signaal verder gaat verwerken, dan gaan bepaalde van die piekjes misschien verdwijnen. Dus in plaats van 1 enkele overgang, wat je normaal wilt, ga je heel wat verschillende overgangen zien. Dat is niet wat we willen: we willen een signaal dat op een bepaald moment van laag naar hoog gaat. \\
Oplossing: Schmitt-trigger-ingangen: speciale implementaties van een ingang: we hebben niet 1 overgang, maar als we van hoog naar laag gaan volgen we de rechtse curve op de rechtsonderfiguur en als we van laag naar hoog gaan volgen we de linkse curve op de rechtsonder figuur.

\paragraph{Slide 27:} Het dynamisch gedrag is heel belangrijk want het bepaalt het tijdsgedrag.

\paragraph{Slide 28:} Wat hier getekend is, is onmiddelijk nadat er overgeschakeld is: de rode geeft geen doorverbinding meer en de bovenste wel. Je zou verwachten dat de spanning onmiddelijk verandert, maar dat gebeurt niet omdat er vertragende elementen in de schakeling zitten. Als je het elektrische equivalent tekent dan is dat het rechtse: je hebt 2 weerstanden (de rechtse: de ingangsimpedantie, wat je aan de ingang ziet en dus niet de weerstand van de rechtsondergroene transistor op de bovenste tekening). Het is de weerstand tussen de gate en de source. Vermits die van elkaar ge\"isoleerd zijn, verwacht je dat die zeer hoog/oneindig is. Er is ergens een weerstand tussen de gate en de source. Capaciteit: je hebt er een wanneer je 2 geleiders naast mekaar hebt, dus 2 draden boven elkaar (meestal geen grote capaciteit). Dus overal in de schakeling heb je eigenlijk een capaciteit.\\
Overal In de schakeling heb je en grond en een verbinding.\\
Hoe langer uw draad is, hoe groter uw capaciteit is: bij lange draden is die groot, bij korte draden is die capaciteit klein. 
Bij de onderste overgang heb je iets verlijkbaar. De ingangsimpedantie blijft altijd. 

\paragraph{Slide 29:} We hebben dit schema, wat we nu gaan doen is een plotse overgang maken van laag naar hoog. Dat heeft tot gevolg dat waar er oorsponkelijk geen spanning op stond, een spanning wordt aangebracht en die schakeling gaat beginnen reageren. Dit is een RC-netwerk. De spanning gaat exponenti\"eel oplopen. De spanning tussen de uitgang van de ene poort naar de ingang van de andere gaat geleidelijk overgaan van een laag niveau naar een hoog niveau. De uiteindelijke spanning is niet de blauwe.\\
De eindspanning zal dan ongeveer gelijk zijn aan de voedingsspanning uiteindelijk.\\
Voor de rest zie je nog dat die overgang niet ogenblikkelijk gebeurt: het duurt een poosje voor je van het laag bereik in het hoog bereik terechtgekomen bent. Dat is heel belangrijk: de snelheid waaraan je kan werken hangt af van hoe snel je uw bewerkingen afwerkt. Je kan uw spanning niet laten zakken als ze nog nooit hoog gworden is. Hoe trager die curve dus omhoog gaat, hoe langer je moet wachten. We streven er dus naar dat de groene curve zo snel mogelijk stijgt. Dat hangt af van die tijdsconstante $\tau$. Die wordt bepaald door de capaciteit en de twee weerstanden: de parallelschakeling ervan.\\
Hetzelfde gebeurt wanneer je een H $\rightarrow$ L overgang hebt. 

\paragraph{Slide 30:}  Nu we dat weten, hoe kunnen we er nu voor zorgen dat die overgang zo snel mogelijk gebeurt? Die ingangsimpedantie moet zo hoog mogelijk zijn (groter dan de uitgangsimpedantie). Als uw ingangsimpedantie zeer groot is, dan is het statisch vermogenverbruik verwaarloosbaar klein. \\
Hoe kiezen we onze uitgangsimpedantie? Hier zitten we met een conflict: stel dat de ingangsimpedantie zeer hoog is, dan zal de tijdsconstante zich verhouden tot $R_{OH}$ * C. We willen $R_{OH}$ dus zo klein mogelijk hebben. \\
Nadeel aan te kleine weerstand: hoe kleiner die is, hoe groter het ogenblikkelijk vermogenverbuik: ogenblikkelijk grote stromen (P(0)). Je hebt dan over de uitgangsimpedantie de volledige voedinsspanning. Dat zorgt voor een groot vermogen. Het is maar ogenblikkelijk, maar als je plots een heel hoge stroom nodig hebt, kan uw voeding in de problemen geraken want die moet die stroom kunnen leveren (voor 1 is dat geen probleem, wel als je er meerdere hebt). Je moet dus dikwlijs een compromisoplossing hebben.\\
Je kan ook proberen van uw C zo klein mogelijk te maken door korte draden te gebruiken: lange draden zorgen ervoor dat je traag moet beginnen werken. \\
Uitgangsimpedantie die je zo klein mogelijk wil ($R_0$): de NMOS-poort is niet erg populair want die heeft statisch vermogenverbruik, maar die is ook qua tijdsgedrag enorm slecht als je dat vergelijkt met CMOS. Waarom is die traag? Je kan geen te kleine weerstand zetten want dan heb je een enorm groot statisch vermogenverbuik, je moet dus een grote weerstand hebben, maar dan heb je dus een slechte tijdsconstante.\\
Je gebruikt NMOS dus niet tenzij je die echt nodig hebt om die open drain te implementeren.

\paragraph{Slide 31:} Dynamisch gedrag van de poort: hoe snel kan je stijgen en dalen: stijgtijd: tijd om van 0 naar 1 te gaan, daaltijd: tijd nodig om van 1 naar 0  te gaan, daar is een zekere tijd voor nodig. We hebben niet een lage spanning en een hoge spanning maar een laag bereik en een hoog bereik, je kan dus meerdere dingen meten: hoe lang duurt het om van het einde van het laag bereik naar het begin van het hoogbereik te gaan,\ldots \\
De stijg- en daaltijd is iets wat niet zo specifiek is aan de poort. De poort speelt daar ook in mee omdat die capaciteit deels door de eigenschappen van de poort bepaald wordt, maar dat heeft weinig/niks met de complexiteit van de poort te maken. Dat is niet het enige wat het tijdsgedrag bepaalt, het bepaalt hoe snel je kan overschakelen van laag naar hoog of omgekeerd, het bepaalt de maximale snelheid waaraan we kunnen werken. Je ziet op die tekening ook dat die stijg- en daaltijd nogal verschillend kunnen zijn, ze wordt bepaald door de weerstand bovenaan (stijgtijd) terwijl de daaltijd berpaald wordt door de transistor (denk ik??). %TODO nakijken! \\
Vertragingstijd: ik zet een signaal op de ingang, hoe lang heeft die poort ervoor nodig om die berekening te doen en dat op de uitgang te zetten? Dat wordt gemeten als wat er op de ingang vershcijnt en wat er aan de uitgang uitkomt. \\
Het probleem is, hoe meet je wanneer de ingang gebruikt wordt en wanneer het resultaat op de uitgang beschikbaar is? Je hebt ook weer 2 soorten vertragingstijd. In vele gevallen is dit ongeveer hetzelfde, in andere gevallen kan dat verschillen. Als je over \emph{de} vertragingstijd spreekt, spreekt men over het gemiddelde.\\
Strikt gezien zou je kunnen zeggen dat de vertragingstijd gekoppeld is aan het interne van de poort. De stijg- en daaltijd heeft te maken met hoe poorten met elkaar verbonden zijn. Stijg- en daaltijd bepalen hoe snel je kan werken. Wanneer je dat op deze manier gaat meten, in de gemeten vertragingstijd zit de echte vertraging van de poort in plus hoe snel die verandert. 

\paragraph{Slide 32:} Korte stijgtijden links: geeft de tijd aan die nodig is om het resultaat te berekenen. Als je een slechte stijgtijd hebt (rechts), dan komt er nog de helft van de stijgtijd bij. \\
In de gemeten vertragingstijd zitten dus beide effecten in: complexiteit van de poorten en hoe ze met elkaar verbinden. Vandaar dat ook, als je wil gaan rekenen, kan je de vertragingstijd meten en met beide aspecten gelijktijdig rekening houden. In de gemeten vertragingstijd ga je dus altijd een combinatie van de twee hebben. $\Rightarrow$ Heel belangrijk!

\paragraph{Slide 34:} Vermogenverbruik: je moet het vermogen kunnen leveren (dat kost aan energie, batterijen,\ldots) en dat vermogen wordt voor iets gebruikt: wordt gewoonlijk omgezet in andere energie, die gaat niet echt verloren. In ons geval betekent dat dat het omgezet wordt in warmte en die moet afgevoerd worden. Als je die niet snel afvoert, gaat uw schakeling enorm snel opwarmen en smelten. Je moet energie dus niet alleen kunnen leveren, ook wegnemen. Voor grote schakelingen is dit ondertussen een van de belangrijkste problemen geworden. Als je weet dat iets op een bepaald moment niet gebruikt wordt, ga je er gewoon de voeding vanaf nemen, maar als je het dan nodig hebt, heb je tijd nodig om in gang te geraken. Voor de rest zijn er heel wat technieken om schakelingen te maken die heel wat minder vermogen verbruiken.\\
Je hebt dus statisch vermogen: vermogen dat je constant hebt en dat je zeker wil vermijden (dat heb je bij NMOS), bij CMOS is dat verwaarloosbaar klein (de belangrijkste reden om CMOS te nemen). Ze hebben beiden dynamisch vermogenverbruik: als ze schakelen: die capaciteiten moeten opgeladen worden en ontladen worden. \\
Je kan nagaan hoeveel energie je nodig hebt om een capaciteit van de ene spanning naar de andere te gangnen. Dat is $CV^2/2$. of je dat nu snel doet of traag maakt niet uit, het verschil zit 'm wel in dat als je het snel doet je ogenblikkelijk veel energie nodig hebt op korte tijd. Om die van de ene spanning naar de andere te brengen is $CV^2/2$.\\
De meeste systemen werken op een klok, hoe dikwijls per seconde kunnen we het signaal veranderen? 2 overgangen (van nul naar 1 en omgekeerd): $CV^2$ aan energie nodig. Voor praktische gevallen kan het dynamisch vermogen beperkt gehouden worden. Hier moet je er ook rekening mee houden dat niet alle poorten tegelijkertijd schakelen, er is geen enkele schakeling waarbij alle poorten tegelijkertijd schakelen. 

\paragraph{Slide 35:} In alle schakelingen moet de PMOS vanboven staan en NMOS vanonder, waarom is dat? Als we die zouden omwisselen, kunnen we niet alleen inverterende schakelingen maken, maar ook een AND poort. 

\paragraph{Slide 36:} Waarom mag dat niet? NMOS-transistoren zijn zeer slechte pull-ups. Een NMOS-transistor is goed om een spanning naar beneden te trekken, PMOS om naar beneden te trekken, daarom staan ze ook in die takken.\\
Waarom is dat zo? Er zijn verschillende redenen. De meest evidente: stel dat we NMOS bovenaan zouden zetten: wanneer gaat de transistor geleiden bij de middelste tekening? Als de spanning voldoende groot is. Om ervoor te zorgen dat we een hoger niveau krijgen moet er een verschil zijn van de drempelspanning van de transistor tussen de gate en de source. Als je bij V een hoge spanning opzet, zal die nooit boven $-V_T$ kunnen geraken, moest die hoger geraken zou de transitor niet meer geleiden. In regimetoestand gaat de uitgang van de linkse poort de hoge spanning $-V_T$ hebben. Wanneer we een bepaalde spanning hierop hebben, wat die ook is, op de uitgang zal altijd een lagere spanning staan. Als je 2 van die poorten na elkaar hebt, dan gaat er hier eerst $V_T$ af en daarna daar $V_T$ erbij. Na een tijd ga je een spanning hebben die lager is dan het lage niveau. Is dat hetzelfde probleem als je die beneden zet? Nee, want daar is het niet de spanning tussen de gate en de uitgang maar tussen de gate en de source en de source ligt daar altijd op nul. \\
Nog een verklaring: die gaat zich zo instellen dat die altijd een beetje blijft geleiden dus gaat altijd ook statisch vermogenverbruik hebben. De boodschap van de dia is dat je nooit NMOS transistoren bovenaan mag zetten, je moet die altijd onderaan zetten. Hetzelde met PMOS: nooit onderaan.\\
Daarom kunnen we alleen maar inverterende basispoorten maken.

\paragraph{Slide 38:} Fan-in: aantal ingangen. Waarom komt dat van pas? Je kan niet een eindeloos aantal ingangen hebben, je kan geen poort maken met 100 ingangen omdat hoe meer ingangen je hebt, hoe slechter de poort gaat werken: de vertragingstijd gaat stijgen: hoe meer ingangen je hebt, hoe meer transistoren je hebt (ingangen $\sim$transistoren), ieder van die transistoren heeft een interne capaciteit,\ldots \\
Ander probleem: als je kijkt naar de tekening rechts boven: een groot aantal ingangen betekent een groot aantal transistoren in serie. Ieder van die transistoren is niet-ideaal: zelfs als die geleidt zal de spanning over die transistor niet exact 0V zijn. Als je er verschillende boven elkaar zet gaat dat allemaal optellen en kan je in het hoog bereik terechtkomen hoewel dat niet de bedoeling is. We gaan daar rekening mee moeten houden, een oplossing voor mogen zoeken.\\
Fan-out (!!!): $\neq$ aantal uitgangen. Fanout = \# ingangen dat aan die uitgang verbonden is. Waarom zijn we daarin ge\"nteresseerd? Ook dat zal onze snelheid gaan bepalen: hoe meer ingangen er aan de uitgang hangen, hoe groter de capaciteit, hoe trager de schakeling werkt. Er is maar een maximale stroom die geleverd kan worden.  Dus hoe groter de fanout, hoe trager de schakeling gaat werken. 
Soms kunnen we daar niet aan ontsnappen: zolang je op een ge\"integreerde schakeling werkt, heb je niet veel energie nodig om het te laten omschakelen. Een keer je vanaf een ge\"integreerde schakeling naar een andere gaat, heb je een lange verbinding en heb je een veel grotere capaciteit. Wil je dus een hogere snelheid halen op een PCB moet je een andere methode zoeken. Het voordeel van op de chip te werken is dat je aan een grote snelheid kan werken. Gegevens uitwisselen met de buitenwereld (dus buiten de chip) gebeurt niet aan een hoog tempo om deze reden.\\
Je kan dat wat verhelpen door ervoor te zorgen dat je een schakeling hebt die wel grote stromen kan leveren: een poort die en hoge uitgangsimpedantie heeft (denk ik? Mss kleine!). %TODO nagaan!
Een driver/buffer dient om vveel stroom te kunnen geven. Die stroom heb je nodig om dingen met een hoge capaciteit toch snel te kunnen laten veranderen. Een keer je vanaf uw schakeling naar uw PCB gaat of van PCB naar randapparatuur heb je buffers nodig die voldoende stroom kunnen leveren om een redelijke snelheid te halen.

\chapter{Les 4}
\section{Sides: 3\_Technologie}

\paragraph{Slide 39:} We hebben besproken hoe poorten gemaakt worden in NMOS en CMOS en welke impact de parameters hebben. Buiten de praktische kanten is er nog een ander aspect: de technologie\"en: hoe wordt dat ge\"implementeerd? Er zijn ook heel wat andere mogelijkheden.

\paragraph{Slide 40:} Als je dat gaan bekijken zijn er 3 grote categorie\"en die gebruikt worden als het over implementatie gaat: standaard chips, programmeerbare logica en specifieke chips.\\
Standaardchips zijn de oudste. De bedoeling was dat je de componenten kocht en die zelf samenzette op een PCB om op die manier een schakeling te maken. Ondertussen is dat wat in onbruik geraakt (die standaardcomponenten worden wel nog gebruikt, voornamelijk als lijm tussen de andere: glue logic). Als je naar een PCB kijkt, dan staan daar een paar belangrijke componenten op die zorgen dat de chip iets specifiek doet. Je hebt een component met verwerkingskracht, uitbreiding,\ldots Ook een klok nodig die gegenereerd moet worden, buffers om meer stroom te leveren wanneer je naar andere componenten gaat of wanneer je van het bord afgaat. Dat is typisch die glue logic, de rommel die erbij staat die functioneel niet erg belangrijk is maar toch nodig is om het te doen werken. Daar zit niet veel evolutie meer in en we gaan dat verder ook niet meer bespreken.\\
Specifieke chips: andere kant van het spectrum. Dat is een enkele component die gans het systeem omvat. Het nadeel ervan is dat het erg duur is om te maken. Het ontwerpproces is redelijk lang, vereist heel wat kennis en het maken vergt ook veel kennis en tijd en energie. Daarom ga je dat alleen doen als je die ontwerpkost kan afschrijven op een heel groot aantal componenten. Bv. als je een microprocessor maakt kan je die voor vanalles en nog wat verkopen. \\
Je hebt ook een tussencategorie voor de kleine aantallen of voor een beperkt aantal ((tien)duizenden componenten), daarvoor zijn de specifieke chips te duur en de standaardchips zijn te eenvoudig. Daarvoor hebben we programmeerbare logica (is geen microprocessor of waarop je kan programmeren), het is een logica waarop je de funcitonaliteit kan programmeren. Je kan de functionaliteit van de component wijzigen. Dat heeft het voordeel dat je de component voor heel wat toepassingen kan gebruiken. Door de stijging van het integratieniveau kunnen we daar heel hoge complexiteiten mee halen.

\paragraph{Slide 41:} Als we iets specifieker gaan kijken, de specifieke chips, daarbij is maatwerk het meest effici\"ente: zo maken dat die optimaal werkt qua snelheid,\ldots

\paragraph{Slide 42:} Je gaat zelf bepalen waar de transistoren allemaal staan, hoe die verbonden zijn, hoe die poorten gaan vormen,\ldots Dat is heel complex (je gaat de ganse schakeling in een keer maken) maar het is het meest efficiente. Door het feit dat je geen overzicht meer hebt, is dat niet goed voor grote schakeling. Het kan wel gebruikt worden als onderste laag die de fabrikant meelevert.\\
Uit de wet van Moore volgt dat  er om de 1.5-2 jaar een verdubbeling is van integratie. Als je op het laagste niveau van transistoren gaat werken, ben je verplicht om uw ontwerp om de 2 jaar helemaal opnieuw te maken, anders ben je niet meer mee.

\paragraph{Slide 43:} Je kan gebruik maken van standaardcellen (het niveau juist erboven, boven de poorten. De poorten kan je uit een bibliotheek nemen). Om het op een structurele manier te regelen wordt het gebruikt in cellen. De hoogte is hetzelfde, de breedte vari\"eert wat en tussen de rijen zitten gaten, daar worden geen transistoren gebruikt. Die dienen om de draden te leggen. Je hebt maar een beperkt aantal metalisatielagen die je boven elkaar gaan leggen, je kan draden niet zomaar boven elkaar leggen/elkaar laten kruisen (zou het veel complexer maken), daarom voorzie je plaats tussenin, dan moet je niet in de hoogte werken.\\
Hoe geberut het ontwerp hier? Je moet eerst een logisch ontwerp maken met alle poorten etc. De volgende stappen zijn:
\begin{enumerate}
\item Bepalen waar welke poort ligt: het is niet omdat je 3 AND-poorten hebt en een OR-poort dat je eerst de ANDs moet leggen en dan de OR. De vraag is wat het beste is: hoe kunnen die verbonden worden met elkaar? We hebben bij voorkeur korte draden zodanig dat de schakeling zo snel mogelijk werkt. 
\item Het plaatsen van die componenten hangt samen met hoe die draden kunnen lopen. $\rightarrow$ Bepalen waar de draden liggen.
\end{enumerate}
Die twee dingen liggen samen, ontwerp je samen. Dit is een niveau dat al veel makkelijker is om ontwerpen te maken. 
Dit wordt heel toegepast op een normaal ontwerp.

\paragraph{Slide 44:} Je kan nog een stap verder en dat is de gate array. Het gaat er altijd om hoe je het goedkoper en sneller kan laten gebeuren. Je kan een beperking opleggen aan het aantal componenten.\\
Waarom geen component maken met alleen maar NAND-poorten op? Het voordeel daarvan is dat je dat \'e\'en keer op voorhand kan maken. Welke schakeling je ook wil hebben, de poorten liggen al vast (vandaar een gate array). Wat moet er dan nog gebeuren? De verbindingen moeten nog gelegd worden. Het grote voordeel is dat de meest dure en complexe stappen al gedaan zijn. De laatste stappen zijn die draadjes leggen bovenaan, dat is goedkoop en eenvoudig. De fabrikant kan een ganse reeks chips maken waar al die poorten opstaan en per gebruiker zal er een andere metalisatie op gelegd worden.\\
Het legt beperkingen op aan wat je kan gebruiken.

\paragraph{Slide 45:} Een andere manier van implementeren die redelijk veel gebruikt wordt (en we gaan toepassen in het labo) en dat is die van programmeerbare chips. We gaan hier geen transistoren verschuiven. 

\paragraph{Slide 46:} Wat je wel kan doen is: stel de poorten liggen vast, je kan de verbindingen wijzigen. Je kan zo andere schakleingen maken. Je kan dit ook doen bij een component die helemaal klaar is. Je kan er wel voor zorgen dat verbindingen wel of niet onderbroken zijn (dat is hetzelfde als een verbinding leggen, maar het is soms makkelijker om te onderbreken).
\begin{itemize}
\item Zekeringen: voorkomen dat er teveel warmte onstaat en daarom schade. %van die "schade" ben ik niet zeker!
Een goede zekering is het eerste wat kapot gaat in uw toestel. Als er een te grote stroom door de zekering loopt, dan brandt die door. Je kan een zekering zetten op een draad en als we niet willen dat daar een verbinding is, dan zetten we daar even een grote stroom op zodat die zekering doorbrandt. Het nadeel is dat dit onomkeerbaar is. Als je later vaststelt dat je een fout gemaakt hebt kan je die in principe niet meer wijzigen, tenzij het enige wat moet gebeuren is het onderbreken van extra verbindingen. We veranderen hier dus niet de poorten, enkel de verbindingen.
\item Op een reversibele manier: we kunnen een transistor laten geleiden of isoleren. Dat komt op hetzelfde neer als de zekering die wel of niet doorgebrand is. Als je zo een transistor op een draad zet en je stuurt die op een juiste manier, kan je ervoor zorgen dat die verbinding er wel of niet is. Je moet alleen de spanning op de gate veranderen om te zorgen dat de verbinding al dan niet gemaakt is. In de meeste gevallen blijf je wel bij uw keuze, dus ook als je de spanning afzet en terug opzet, wil je dat dat behouden blijft, je wil dat op een niet-vluchtige manier doen. Je kan dezelfde techniek als in flashgeheugen hier toepassen: 2 gates: de bovenste is verbonden met de buitenwereld, de middelste is totaal ge\"isoleerd (floating gate). Hoe kunnen we die nu gebruiken? Dankzij quantummechanica weten we dat het kan gebeuren dat een elektron op een bepaald moment op een plaats is en op een ander ogeblik ergens anders zonder dat het ergens tussenin geweest is. We kunnen daarvan gebruik maken. Door de juiste spanninng op te leggen kunnen we ervoor zorgen dat elektronen die zich op de bovenste poort bevinden zich plots op de onderste poort bevinden. We gaan elektronen overpompen van boven naar die middenste poort. Als je de spanning afzet, kunnen de elektronen niet meer wegtunnelen (dat kan alleen als je de juiste spanning aanlegt). Als je dan de spanning opnieuw aanlegt, dan zullen die elektronen weer geleiden. Je kan dit ook omkeren: die elektronen terug naar de bovenste poort laten gaan. Op die manier kan je een transistor gebruiken om verbindingen te maken en onderbreken. Je kan dit omkeren, maar dat gaat niet zo simpel (vrij traag). Je kan dat ook niet blijven doen, uiteindelijk krijg je daar toch neveneffecten van en dan werkt dat niet zo goed meer, maar normaal wil je dat ook niet. 
\item Tegenwoordig vind je SRAM het meeste terug: aansturen vanuit een geheugen. We hebben een transistor die voor de verbinding zorgt, een geheugen dat aangeeft of de transistor moet geleiden of niet. Als dit een statisch RAM-geheugen is, gaat de informatie verloren wanneer je de spanning afzet. Je kan ergens bijhouden (in een niet-vluchtig geheugen) wat wel en niet moet doorlaten. Tijdens het resetten wotdt die informatie gewoon overgepompt naar uw SRAM. Het voordeel daarvan is dat het herprogrammeren heel vlot verloopt: gewoon nieuwe informatie in het RAM-geheugen inladen. Dat kan aan hoge snelheid en je kan het vaak veranderen. In extremis kan je die component dat zelf laten doen, maar dat is erg moeilijk want het is moeilijk bij te houden wat er nu juist aan het gebeuren is.
\end{itemize}

\paragraph{Slide 47:} Hoe ziet dat eruit? Een laag AND-poorten en een laag OR-poorten. Je hebt dus een laag AND-poorten gevolgd door een laag OR-poorten, daarmee kan je elke mogelijke schakeling maken. Het enige wat je hierbij moet doen is programmeren hoe de ingangen met elkaar verbonden zijn (via de utigangen). Dat is dan het programmeren en daarmee kan je een schakeling maken. \\
Als we gaan kijken naar de kostprijs: de poorten gaan niet meer de kostprijs bepalen, wel de plaatsen waar je al dan niet verbindingen maakt. Het wordt dikwijls zo getekend, hoe interpreteer je dat: een beknopte schrijfwijze om de rechtse tekening weer te geven. Tussen ieder van die dingen (bolletjes) zit een zekering. Je kan er sommige dan opblazen en dan krijg je kruisjes en dan weet je wat al dan niet gaat geleiden.\\
Het is een XNOR-poort op de slide. Kruisje: zekering die is doorgebrand.\\
Problemen: snelheid en betrouwbaarheid. Hoe groter die matrices worden, hoe langer de afstanden worden en hoe trager het systeem wordt. De snelheid is dus veel lager dan de echtstreekse implementatie.\\
Betrouwbaarheid: hoe test je een zekering: opblazen en testen of het goed gebeurd is. Een keer je dat gedaan hebt moet je die eigenlijk weggooien. Je kan dat dus nooit helemaal testen: bij een paar testen en aannemen dat de rest ongeveer ook zo zal zijn.\\
Die lagere snelheid dan rechtstreekse verbinding en onbetrouwbaarheid zorgt ervoor dat men die volledige flexibilteit niet altijd zal gebruiken, sommige dingen zal men vastleggen: de OR-poorten onmiddelijk aan de AND-poorten hangen bv.\\
Dan krijgt dat andere namen: PAL: vaste OR-matrix. 

\paragraph{Slide 48:} Naarmate dat we naar een hogere integratie konden gaan, is men gaan beseffen dat je alle kan implementeren met tweelagen-logica, maar als je bv. een flipflop wil gaan maken, heb je daar 8-10 poorten voor nodig. Als je dat via de trage AND-OR verbidngingen gaat doen, werkt dat heel traag. Als je weet dat je toch in 80\% van de gevallen een geheugenelement nodig hebt, zet dat er dan gewoon bij. In die overige 20\% ga je dat niet gebruiken en staat het wat in de weg, maar voor die 80\% verantwoordt het wel die extra meerkost.\\
Men gaat de dingen waarvan men verwacht dat die regelmatig gaan gebruikt worden, die gaat men erbij zetten. Op de slide: 1-bitgeheugen erbij gezet en een selector die zegt of het gehuegenelement gebruikt wordt of niet. Men spreekt dan van macro-cellen: de uitgang wordt complexer en er zitten verschillende functionaliteiten in. \\
We kunnen alsmaar meer op een chip zetten. Als we die matrix gaan uitbreiden, gaat de chip eerder met de matrix volstaan, niet zozeer met de schakelingen. Je hebt altijd een paar componenten die met elkaar verbonden moeten zijn, maar niet alles moet altijd met alles verbonden zijn. Die heel grote matrix is dus niet altijd effici\"ent.

\paragraph{Slide 49:} Soms is het interessanter om verschillende kleinere dingen te nemen. In plaats van alles groter te maken, gaan we verschillende kleine matrices gebruiken zodanig dat die lokaal verbonden kunnen worden en weinig verbonden moeten worden met de rest. Sommige dingen gaat men dan onderling wel nog gaan verbinden.

\paragraph{Slide 50:} Wat we tot hiertoe gedaan hebben is de logica, de poorten die erop staan, die staan vast. Het enige wat we konden programmeren waren de verbindingen. We kunnen nog een stap verder gaan, dat is de meer recente programmeerbare logica. We kunnen niet alleen de verbindingen programmeren, maar ook de poorten. Dan komen we tot de FPGA. \\
Als je gaat kijken heb je een matrix van logische blokken. Dat is die basiscomponent waarvan je ook de functionaliteit (die nog niet bestaat) kan bepalen.\\
Het is field programmable: gelijk waar, je moet daarvoor niet naar de fabriek gaan, geen heel speciale apparatuur voor nodig. Het is in dit soort schakelingen dat daarom die transistoren aangestuurd worden vanuit een geheugen.\\
Wat zit daarin? Je hebt enerzijds de logische blokken en iedere logische blok kan een bepaalde functionaliteit hebben. Je kan er natuurlijk maar iets mee doen als die verbonden zijn met elkaar. Je hebt 2 soorten verbindingen:
\begin{itemize}
\item Lange lijnen die lopen over de ganse component want soms kan het gebeuren dat je informatie moet delen met heel wat andere logische blokken en dan ga je typisch een busstructuur gebruiken en die gaat op verschillende plaatsen gebruikt worden. Op die ogenblikken is zo'n lange lijn heel interessant. 
\item Als je toch snelheid wil hebben, moet je kortere verbindingen hebben. Daarvoor gebruiken we de schakelmatrices: die gaan u de mogelijkheid geven om elke lijn die erop toekomt te verbinden met elke andere lijn, die kan dat zelfs met meer dan een andere lijn verbinden. De lichtere dingen die er nog tussenstaan (SMc) dienen om de horizontale en verticale lijnen te raken, de verbinding naar de lijnen die naar de schakelmatrices gaan. 
\end{itemize}
Je hebt bijkomend heel korte verbindingen die rechtstreeks 2 naburige blokken verbinden.\\
Je moet nog naar de buitenwereld gaan, dus je hebt ook IO-blokken nodig.\\
Als je dat gaat bekijken binnen een ontwikkelomgeving: de blauwe dingen op slide (via animatie komt die erop te staan): logische blokken. Paarse lijnen zijn de lange lijnen die over de ganse lengte doorlopen. Om een bus aan te sturen met meerdere, dan moet dat met tristate buffers, dat zijn die kleine driehoekjes. Die staan erop, of je die nu gebruikt of niet. De witte lijnen zijn de kortere lijnen. De schakelmatrices maken dus gewoon verbindingen tussen lijnen. De blauwe puntjes (nauwelijks zichtbaar) maken ook verbindingen.

\paragraph{Slide 51:} Als je weet dat bepaalde dingen veel gebruikt worden, ga je dat niet met basiscomponenten implementeren, dan zet je dat daar gewoon bij. Gewoonlijk ga je sequenti\"ele schakelingen maken. Wat heb je daarvoor nodig? Geheugen (op die van de labo's zit extra geheugen op: het groene op de tekening). Sequenti\"ele schakelingen werken op een klok, dus dat heb je ook nodig (zit er automatisch op, dat is dat zwart blokje DCM). Dat kan nog verdergaan: vermenigvuldiger. Een optelling kan je redelijk effici\"ent met die logische blokken maken, een vermenigvuldiger niet, daarom zijn er vermenigvuldigers bijgezet.\\
Als je naar complexere toepassingen gaat kijken kan er veel meer opgezet worden: meer geheugen, alle componenten die je denkt nodig te hebben: aansturing van ethernet,\ldots \\
Wat als je bepaalde componenten niet nodig hebt? Je hebt verschillende soorten FPGA's: met bepaalde componenten of zonder. 

\paragraph{Slide 52:} We hebben 2 manieren om te programmeren: het maken van verbindingen en bijkomend een basiscomponent waarvan we de functionaliteit ook kunnen aanpassen. Dat geeft enorm veel flexibiliteit.\\
Daar zitten dus geen poorten in waarvan je de schakeling kan wijzigen!\\
Wat hier is weergegeven: wordt ge\"implementeerd met een geheugen: een opzoektabel implementeren. Dat geeft voor elke combinatie van de ingangen (hier 4 bits ingangen dus 16 mogelijkheden) aan of de uitgang 1 of 0 moet zijn. Die lookup table bepaalt dus de functionaliteit.\\
Wat je nu ziet is de waarheidstabel. Op het moment dat je de waarheidstabel hebt moet je niet meer nadenken wat het wordt in termen van AND en OR, je steekt dat in het geheugen en de component doet wat hij moet doen. Je hebt wel de beperking dat je meestal maar met 4 ingangen kan werken. Elke logische blok kan dus gelijk welke functie van 4 ingangsvariabelen realiseren.
Dit is de manier waarop je een programmeerbare component kan maken.

\paragraph{Slide 53:} Spartan-3: je hebt een logische blok (CLB: configurable logic block) en elke slice is opgedeeld in 2 logische cellen, zie \textbf{Slide 54}.

\paragraph{Slide 54:} Binnen 1 configureerbare logische blok zitten 8 logische cellen in, dus je gaat altijd 8 logische cellen met een keer gebruiken. Als je hiernaar kijkt, kan je denken dat het nodeloos ingewikkeld gemaakt is. Ook hier geldt: wat zetten we erbij? $\rightarrow$ Dingen die we goed denken te kunnen gebruiken. \\
Door er een beetje hardware bij te zetten (in het lichtgroen) kan je met een logische cel een optelling maken. Het is de moeite waard om dat te hebben.\\
Evengoed hebben we dikwijls extra geheugen nodig, dat is in het blauw aangegeven.\\
Dat rode stukje: die kiest tussen 2 ingangen. Door alleen deze erbij te zetten kan je die 2 logische cellen combineren tot iets nieuw. Als je dus 2 logische cellen hebt, heb je 2 keer een functie van 4 variabelen. Maar heel dikwijls heb je meer variabelen nodig. Door die rode selector erbij te zetten, kan je die 2 samenzetten tot 1 functie van 5 variabelen: je splitst uw waarheidstabel in 2 op: 1 waarbij de meest beduidende variabele 0 is en een waarbij de meest beduidende variabelen 1 is. Op die manier, door het feit dat die selector daar wijzigt, kan je een fucntie van 5 variabelen realiseren.

\paragraph{Slide 55:} Schakelmatrices: de verbindingen worden gemaakt/verbroken met transistoren.  Hier is het getekend met NMOS-transistoren, in de realiteit is dat ingewikkelder.  Je kan het programmeren vanuit een RAM-geheugen dat die poorten aanstuurt. 

\paragraph{Slide 56:} Je hebt een ontwikkelomgeving specifiek voor het soort componenten dat de fabrikant verkoopt.

\paragraph{Slide 57:} CAD-omgeving waarbinnen je het volledige ontwerp kan doen en dat je zoveel mogelijk zal helpen om alle taken te doen. De basistechnieken zijn al ge\"implementeerd in de software en zullen voor u verzorgd worden.\\
Linksboven: project met bestanden. Je kan daar hi\"erarchisch in werken. Je kan daar verschillende dingen op doen. Je hebt ook een venster met het resultaat. Rechts: overzichtsschema met ofwel schema ofwel resultaat van simulaties.

\paragraph{Slide 59:} Je bent niet verplicht om gebruik te maken van 1 manier van input ingeven. In het voorbeeld op de slide is alles wat gecombineerd. Je hebt een topschema met een paar dingen die al een beetje uitgwerkt zijn, andere dingen zijn nog gewoon blokjes met een subschema waarop je kan klikken, dan wordt een lager niveau geopend en kan je dat ook in detail zien. \\
Ook nog andere dingen die afhangen van fabrikant tot fabrikant zoals bv. die logiCORE, soort macro.  Om dat allemaal afzonderlijk in de bibliotheek te hebben, ziet men een soort macro. Dan wordt er nog een venster geopend waarin je instellingen kan maken (zie transitie slide). Dit komt een beetje overeen met VHDL. Je moet niet weten wat daar allemaal onderzit, de omgeving zal daar rekening mee houen.\\
Hetzelfde met de specifieke klokinstellingen. \\
Als we het over sequenti\"ele schakeligen hebben, gaan we in eerste instantie toestandsdiagrammen gebruiken. Je kan zelf een toestandsdiagram tekenen en die software weet hoe je dat toestandsdiagram effici\"ent moet omzetten naar hardware. Alle tussenliggende stappen moet je dus niet doen. Je kan ook een VHDL-beschrijving doen. Soms is dit veel compacter.\\
Je kan dit allemaal gaan combineren in uw schema.

\paragraph{Slide 60:} Je kan in die omgeving een logische simulatie doen. Dan krijg je daar de gegeven tekening uit: je kan ingangssignalen aanleggen, zien waar er een reset gebeurt,\ldots Het telt hier op een decimale manier.\\
Je kan ook elk bitje afzonderlijk bekijken hoe het zich in de tijd gedraagt maar dit is geen tijdsgedrag, alleen een benadering want het toont alleen de logische werking. Er staat geen timinginformatie. Zelfs als hier tijden bij vermeld staan, is het geen echte timinginformatie.

\paragraph{Slide 61:} Als je daarmee tevreden bent, moet je uw fysisch ontwerp gaan doen. Je moet gaan zeggen hoe je alles in de logische cellen steekt. Dat heeft dus niks met poorten te maken. Wat als je heel complexe berekeningen hebt op 27 bits, wat ga je in welke cel steken, hoe ga je ze verbinden, waar ga je welke cel zetten,\ldots ? $\rightarrow$ Moet allemaal bepaald worden.

\paragraph{Slide 62:} Dat gebeurt automatisch. Er zijn verschillene stappen die moeten doorlopen worden: alle schema's moeten samengezet worden. Dan moet dat vertaald worden naar logische primitieven, men moet er een logisch ontwerp van maken: poorten en flipflops. Maar er staan geen poorten op uw FPGA. Dan komen de specifieke dingen: wat kan je het best gebruiken, hoe ze je die logische schakeling het best om? \\
2 stappen: logische schakeling maken en dan die zo goed mogelijk vertalen naar wat er op die FPGA komt. Dan heb je bepaald wat op die cellen moet komen en hoe ze verbonden zijn. Maar dan heb je hetzelfde probleem: welke cel zet je op welke plaats?\\
Hier heb je eveneens een placement en routing stap. Als dat allemaal gedaan is, is uw fysisch ontwerp af, je hebt dan alle informatie: je weet wat welke cel doet, hoe die met andere cellen verbonden is en als fabrikant ken je de specificaties van die logische verbindingen en kan je het tijdsgedrag gaan voorspellen.

\paragraph{Slide 63:} Simulatie doen die eruit ziet als getoond, hier is de tijdsinformatie wel de echte tijdsinformatie. De piekjes die je ziet, waren er daarnet niet.\\
Transitie slide: de twee enen moeten nul worden en de tweede nul moet 1 worden. Het tijdsverloop toont wanneer welke bit verandert: er is altijd maar 1 signaal dat tegelijkertijd verandert. Alle piekjes die je zag op het vorige beeld (voor de transitie) zijn ook niet zo erg, de tijdssimulatie zegt u alleen wat zal gebeuren, jij moet dan beslissen of dat OK is of niet. 

\paragraph{Slide 65:} FPGA: omcirkeld (en helemaal zichtbaar). De rest zijn allemaal dingen om te experimenteren, drukknoppen,\ldots

\section{Slides: 4\_Combinatorisch}

\paragraph{Slide 1:} We gaan beginnen ontwerpen met de eenvoudigste schakelingen: combinatorische schakelingen. De ingang verandert en zal impact hebben op de uitgang, maar houdt geen rekening met het verleden: heeft dus geen gehuegen.

\paragraph{Slide 2:} Alle dingen die op schema's zijn uitgelgd, hoe ga je dat in een hardwaretaal beschrijven? We beginnen met de combinatorische schakelingen, we willen die minimaliseren.

\paragraph{Slide 3:} De eerste vraag die je je kan stellen is: waarom zou je dat willen? Het is omwille van de randvoorwaarden dat je wil minimaliseren. We streven naar een schakeling die zo goedkoop mogelijk is, zo snel mogelijk werkt en zo weinig mogelijk vermogen verbruikt. Het derde is niet vermeld op de slide, dat is evenredig met de capaciteit maal de frequentie maal de spanning in het kwadraat.\\
Hoe gaan we zorgen dat we zo weinig mogelijk vermogen verbruiken? Als we de frequentie en de spanning constant houden, hangt het dus af van de capaciteit. Die hangt af van de grootte van de component. Als we dus zo compact mogelijk werken, zullen we ook een minimum aan vermogen verbruiken.\\
Om 2 implementaties te kunnen vergelijken meoten we een maat hebben om de kostprijs en snelheid van een schakeling te kunnen bepalen.\\
De kostprijs is het makkelijkste: we hebben gezien dat de kostprijs van een poort evenredig is met het aantal ingagnen bij CMOS. Het hangt er wel vanaf welke technologie gebruikt wordt. Als het een niet-inverterende poort is, die kost nog eentje extra (alleen voor CMOS). Gaan we naar iets totaal anders kijken zoals de FPGA, daar telt het aantal transistoren niet. Daar hangt de kostprijs er vanaf of je een kleine of een grote FPGA kan gebruiken (met kleine logische cellen of grote). Het is hier evenredig met het aantal logische cellen. De kostprijs wordt hier dus anders bepaald. Dit is moeilijk omdat het moeilijk is om te schatten hoeveel logische cellen je gaat gebruiken.\\
In de praktijk moet je je daar niet teveel zorgen om maken. Het eerste (CMOS) is dus meer als je zelf een ge\"integreerde schakeling gaat maken.\\
De kostprijs van de schakeling is de som van de kostprijzen van de afzonderlijke elementen.

\paragraph{Slide 4:} Vertraging: moeilijker. Vertraging is niet alleen een functie van de complexiteit van de poort, maar ook van de stijg- en daaltijd. Die hebben te maken met hoe die poorten verbonden zijn met elkaar. Dat kan je nooit op een logisch schema zien, dat kan je alleen berekenen indien je een fysisch ontwerp hebt. Om dat toch enigzins te kunnen vergelijken, is er een benadering. Er is een stuk dat evenredig is met het aantal ingangen van de poort en dat is de complexiteit van de poort die je in rekening brengt (hoe meer transistoren, hoe trager het zal zijn). Er staat ook nog een constante bij (0.6 en 1.6) om rekening te houden met de verbindingen. Het probeert beide dingen dus te combineren. Dit geldt weer alleen voor CMOS, niet voor FPGA, daar is het te complex.\\
De totale vertraging is de som van de vertragingen langs het kritisch pad: dat pad van een ingang naar een uitgang dat voor de grootste vertraging zorgt. Als je dat pad volgt, dat is de traagste manier om van een ingang naar een uitgang te gaan. Het is het traagste pad dat de maximale verwerking bepaalt.\\
Bv. voor die XOR: donkerblauw is 1 poort (geen 3). Van die \'e\'en enkele poort kan je de kostprijs en de vertraging berekenen. De poort heeft 4 ingangen en is inverterend, dus $0.6+4*0.4$. De vertraging van de ganse schakeling is die door ook nog de inverter, er zijn hier 2 kritische paden: door de inverters en ze hebben dezelfde vertraging (anders hadden we geen 2 kritische paden), dus nog +1.

\paragraph{Slide 6:} Karnaughkaarten: wat we tot hiertoe gezien hebben is dat je dat kan oplossen door algebraisch te werken met Boole-algebra. Maar dat is niet echt handig omdat je niet weet welke theorema's je in welke volgorde moet gebruiken om tot het minimum te komen. De waarheidstabel toont het al meteen in sommige gevallen. In het voorbeeld zie je dat de uitgang 1 is in de $5^e$ en $6^e$ rij. Om die twee gevallen te combineren kan je gewoon zeggen dat f=1 als x=1 en y=0, z doet er niet toe. Je kan dat natuurlijk niet zomaar in alle gevallen zien. Je kan evengoed de groene illustratie zien: f=1 als z=1. maar dat is minder makkelijk om te zien omdat het niet meer naast elkaar ligt. 

\paragraph{Slide 7:} N-kubus met zoveel dimensies als er variabelen zijn. Als we maar 2 dimensies hebben is het doenbaar, ook bij 3, maar daarna is het niet meer te zien. Visueel ben je dus niets met een N-dimensionale kubus, maar het principe is niet slecht. 

\paragraph{Slide 8:} Oplossing: N-kubus die je platduwt: je maakt die 2-dimensionaal. Op de slide heb je een 3-D kubus die is platgeduwd. 000 ligt naast 001, dat moet in het 2-D geval nog altijd zo zijn! We kunnen hier heel makkelijk tot 4 variabelen weergeven. Als je 2 dimensies hebt en je wil dat uitbreiden, ga je spiegelen rond een bepaalde as.

\paragraph{Slide 9:} Spiegelen: de spiegeling van 1 is 3. \\
De mens is heel goed in het herkennen van patronen, maar je moet die wel kunnen herkennen. Je hebt de binaire voorstelling en gaat telkens 1 bit veranderen. Als je 5 bits hebt, heb je 5 mogelijkheden: 5 groene veldjes. 5 variabelen gaat minder makkelijk: wat ligt er allemaal naast 5: alle rode. Dat 21 ernaast ligt is minder evident om dat te herkennen. Die ligt niet aleen in het andere vierkant, maar ook gespiegeld in het andere vierkant. Dat maakt het soms heel moeilijk om het nog visueel te interpreteren.\\
In plaats van te spiegelen kan je ook gewoon dupliceren. In dat geval moet je wel gewoon op dezelfde plaats kijken en dat is al wat makkelijker. 

\paragraph{Slide 10:} Werkt goed voor een beperkt aantal variabelen, maar eens je meer variabelen hebt dan 4, wordt het moeilijik om het visueel te kunnen oplossen. \\
Als je een karnaughkaart met 6 variabelen moet oplossen op het examen, kun je met 99.999\% zekerheid zeggen dat je een fout hebt gemaakt.

\paragraph{Slide 11:} Hoe gaan we dat gebruiken? We hebben dat daarnet gemaakt om visueel te zien wat naast mekaar ligt. Als je van een logische functie vetrekt, kan je die gebruiken om uw kaart op te vullen. In zo'n kaart ga je zo'n groot mogelijke gebieden maken die een macht zijn van 2. Hoe groter dat gebied is, hoe meer variabelen je in je poort kan laten vallen. Als je dat op het voorbeeld bekijkt: gebied van 4. Hoe goed je ook zoekt, je vindt geen gebied van 8. Dan zoek je nog naar de anderen: onderaan kan je samennemen en ook verticaal. Er mogen gebieden overlappen! Zo heb je een vorm gevonden die veel compacter is dan uw oorspronkelijke beschrijving.\\
Karnaughkaarten zijn gebaseer dp het herkennen van patronen. De vraag is of er nog andere patronen te herkennen zijn die nuttig zijn voor een implementatie: dambordpatroon. Dat komt overeen met een XOR. 

\chapter{Les 5}
\section{Slides: 4\_Combinatorisch}

\paragraph{Slide 12:} We hadden het over combinatorische schakelingen waarbij de uitgang afhankelijk is van de ingangen, er is geen voorgeschiedenis.\\
We hebben Karnaughkaarten bekeken, we gaan dat nu iets verder in detail bekijken, want voorlopig hebben we altijd een aantal ingangen en enkele uitgangen gehad, maar in realiteit heb je soms ongespecifi\"eerde uitgangen. \\
Er zijn altijd onmiddelijk 2 oplossingen: SOP en POS, dus er zijn automatisch 2 mogelijke implementaties. Het minimaliseren ging erom dat we een zo goedkoop mogelijke oplossing, een zo snel mogelijke oplossing en een oplossing die zo weinig mogelijk vermogen verbruikt willen.  We willen de implementatie doen met een minimum aan transistoren.

\paragraph{Slide 13:} Implicanten: producttermen waarvoor de uitgang 1 is. De 1-mintermen behoren daartoe, zoals je op de slide ziet. Dat zijn niet de enige, je kan ook producttermen hebben waarin minder variabelen zitten, zoals op de rode rij. Dat zijn allemaal implicanten die gebruikt kunnen worden om die functie te realiseren wanneer we op zoek gaan om de ene te realiseren.\\
Priemimlicanten: speciale soort: dat is de compactste manier om iets voor te stellen, er is geen compactere manier en alle manieren die eronder vallen zijn duurder. Het is een implicant die geen onderdeel is van een grotere. De blauwe is een priemimplicant want er is er geen die groter is. We hebben in het voorbeeld maar 2 priemimplicanten. \\
Wanneer we gaan implementeren is het het interessantst om de priemimplicanten te gebruiken, want als het geen priemimplicant is, is er altijd een effici\"entere manier om het uit te werken.\\
Dekking: welke implicanten hebben we allemaal nodig om de functie volledig te realiseren? Dat kunnen er verschillende zijn. De oplossing die gebruik maakt van de priemimplicanten is veel effici\"enter.

\paragraph{Slide 14:} Wij gaan vertrekken van een Karnaughkaart, in andere gevallen/oplossingen kan je van iets anders vertrekken (bv. tabellen). Wat daarachter komt is essenti\"eel hetzelfde. We hebben al gezien dat het de priemimplicanten zijn die het interessantst zijn om te gebruiken, dus we gaan die eerst bepalen. Er is een speciaal soort priemimplicanten: de essenti\"ele priemimplicanten. Dit zijn degenen die je echt nodig hebt om het te implementeren. De essenti\"ele heb je echt nodig en je weet dat je die nodig hebt door het feit dat er minstens 1 1-minterm inzit die in geen enkele andere priemimplicant voorkomt, er is geen enkele andere beschikbaar waarmee je het kan doen, dus die is essenti\"eel. Dan gaan we zien of we nog iets anders nodig hebben, we vullen dat dan aan (liefst met priemimplicanten) tot alle enen bedekt zijn.

\paragraph{Slide 15:} De eerste stap is het maken van de Karnaughkaart. Je moet enen invullen waar ieder van die termen 1 is. De groene vakjes zijn die waar de stelling waar is. Zo doe je dat term per term. Die enen mogen overlappen, ze mogen alleen niet contradicteren.

\paragraph{Slide 16:} We hebben nu de Karnaughkaart gemaakt en daarmee gaan we aan de slag. We gaan nu kijken naar een stap-voor-stap oplossing die altijd werkt. Er is ook een snellere manier, maar die is ook gevaarlijker (je ziet makkelijker dingen over het hoofd).\\
Hoe komen we tot alle priemimplicanten? We gaan die enen een voor een aflopen. Voor iedere 1 gaan we de priemimplicanten zoeken waar die 1 deel van uitmaakt. Als we naar die eerste kijken, hebben we 2 1-mintermen die eraan voldoen. We kunnen er geen van 4 zoeken waarin de linksbovenste 1 inzit. We kunnen geen van 4 vinden, de grootste is dus van 2. De bedoeling is dat we alle priemimplicanten met een grootte van 2 opsommen, in dit geval zijn dat er dus 2. Dat resulteert dus onmiddelijk 2 priemimplicanten. Bij de volgende 1 kunnen we 4 enen samennemen en weerom zijn er 2 mogelijkheden, velden van 4, waar die 1 in voorkomt, dus er komen weer twee priemimplicanten bij. Bij de volgende 1 komt er geen priemimplicant bij (we hadden die al), zo kan je verdergaan en priemimplicanten identifcieren. Uiteindelijk heb je de volledige lijst van priemimplicanten. 

\paragraph{Slide 17:} Nu je die priemimplicanten hebt moet je de essenti\"ele gaan zoeken. De essenti\"ele zijn degenen die een 1 bedekken waar geen enkele andere priemimplicant overkomt. Je kan dat zien op de Karnaghkaart. Op veel plaatsen zijn verschillende gebieden die overlappen, bij 2 enen is er maar 1 term die de 1 bedekt. Dat zijn dus termen die priemimplicanten zijn. Door het feit dat je die gekozen hebt, heb je al een zekere dekking. De rechtsbovenimplicant zal ook andere enen bedekken, we hebben zo al 8 enen bedekt. Zo moet je gaan kijken of er nog enen zijn die niet bedekt zijn (zijn er 2) en van die resterende implicanten een liefst zo klein mogelijke priemimplicant zoeken zodanig dat die resterende enen ook bedekt worden. Tot hiertoe kon je met zekerheid zeggen wat erin moest zitten, maar nu wordt het iets moelijker want je moet het globale overzicht hebben en kijken welke priemimplicanten je gaat gebruiken. In de praktijk is dat vaak moeilijk en gaat men iteratief te werk en gebruikt men een gulzige manier van werken: eerst de priemimplicant zoeken die zoveel mogelijk bedekt, dan de tweede die dat doet,\ldots je kan in een lokaal optimum terechtkomen, maar het kan zijn dat het niet de meest minimale oplossing is. In praktijk ga je er meestal wel terechtkomen. We gaan van iedere priemimplicant zoeken hoeveel die bedekt en dan gaan we die nemen die de meeste enen bedekt. Uiteindelijk kom je op de oplossing getoond op de slide, dat is een minimale standaardoplossing.

\paragraph{Slide 20:} Je kan ook kijken naar de nullen in plaats van naar de enen. Je krijgt dan de kaart zoals getoond. Ook hier ga je op dezelfde manier tewerk: zo groot mogelijke gebieden zoeken die een nul realiseren. Je zoekt de essenti\"ele, die minimale gebruiken en dan zoeken wat je nog nodig hebt. Op zich is dat niet zo erg verschillend, maar er is een groot gevaar: het is hier iets minder makkelijk om die term te omschrijven die die nullen bedekt. Als je concreet kijkt naar de rood omcirkelde, hoe beschrijf je dat? Moesten daar enen staan, zou je zeggen zw'y'. Maar er staan geen enen, er staan nullen, dus je moet er het complement van nemen, de beschrijving die dat beschrijft is (zw'y')'. Met de wet van De Morgan kan je dat omzetten naar w+y+z' want nu ben je niet op zoek naar en SOP maar naar een POS. je kan dat via de omweg doen zoals net uitgelegd, je kan ook rechtstreeks naar de kaart kijken en bv. zeggen: er staan 2 nullen, dus op alle andere plaatsen staan enen. Hoe kan je die gaan beschrijven? Alle enen onderaan is w, alle enen rechts is y en alle zijkanten is z' en dat is meteen een OR-verband.\\
Hier zie je die 5 priemipmplicanten. Dan moet je de essenti\"ele gaan zoeken en weerom, over twee nullen komt er maar 1 priemimplicant.Op dit moment staat er is zo'n vakje een 1 of een 0, die zijn complementair ten opzichte van elkaar. 

\paragraph{Slide 21:} We gaan gebruik maken van volledig gespecifi\"eerde functies. Dat betekent dat we niet voor iedere combinatie van ingangen een zinvolle uitgang hebben.

\paragraph{Slide 22:} Soms kan het ons niet schelen wat er op een uitgang komt voor die ingangscombinatie. Een reden daarvoor is dat het niet kan voorkomen dat die combinatie aan de ingang gaat staan. Dan zegt men dat die uitgang ``don't  care" is. We hebben nu al 4 mogelijkheden om een signaal aan te geven: 0, 1, Z \& don't care. De mogelijkheden om een binair signaal te beschrijven nemen alsmaar toe. Een voorbeeld waarbij je dat makkelijk ziet waarom dit optreedt is een 7-segmentdisplay van een BCD-getal (binary-coded decimal). Je kan dat op zo'n display weergeven. Je hebt 4 ingagngen en 7 uitgangen. Als je een 0 wilt tonen, moeten alle uitgangen branden buiten het middelste stuk,\ldots De tabel is nog niet helemaal opgevuld eens we 9 hebben voorgesteld. Je kan zeggen dat het u niet kan schelen wat eruitkomt. We geven dat aan met een streepje. Er zijn verschillende manieren om dat te doen (in het boek: d, vaak ook X). Wanneer we dat ontwerp maken, verdwijnt die don't care en wordt die omgezet naar een 0 of een 1.

\paragraph{Slide 23:} Hoe maak je daar gebruik van? Wat is het voordeel van een don't care vs. allemaal nullen? De don't care heeft het voordeel dat je die zowel voor een 1 als een 0 kan gebruiken zoals het u uitkomt. Je kan die gebruiken om gebieden groter te maken als dat interessant is. Je hebt bv. de kaart op de slide (links), als je die kaart hebt en je gaat daar een SOP van maken, als je daar zo groot mogelijke gebieden zoekt, kan je don't cares gebruiken om die te zien als een 1 en kan je grotere gebieden maken, zo kan je een ingang minder gebruiken aan uw poort. Zo'n don't care geeft u dus de mogelijkheid om uw implementatie effici\"enter te maken: je kan kiezen wat u het beste uitkomt. Als je gaat kijken, wat is er nu met die don't care gebeurd eens je dat gemaakt hebt? Als je de blauwe gebieden als priemimplicanten gebruikt voor de implementatie, de onderste don't care is dan een 1 geworden want je hebt de onderste rij samengenomen (anders mocht je dat niet samennemen). Evengoed zijn de twee bovenste don't cares enen geworden. De tweede onderste is een nul geworden al je heb die niet gebruikt om er een 1 van te maken. Na de implemenatie bestaan er dus geen don't cares meer, je gebruikt dat enkel tijdens het ontwerp, maar eens je de implementatie gemaakt hebt, bestaat dat niet meer. Hier is het nu ook zo dat als je de nullen zou implementeren, dat dat niet automatisch een complementaire implementatie is: rechtse tekening: je neemt de twee bovenste erbij om een groter gebied van nullen te maken en de tweede onderste gebruik je ook als nul, de onderste is een 1 geworden. Het is dus niet zomaar het complement van de linkse tekening! Het is natuurlijk niet zo dat dat de ene keer 0 en de andere keer 1 is, het hangt er vanaf, van uw implementatie. Indien het mogelijk is, ga je zoveel mogelijk don't cares in uw Karnaughkaarten proberen in te schrijven.

\paragraph{Slide 24:} Een normale schakeling heeft meer dan 1 uitgang. Op het eerste gezicht lijkt dat niet zo erg want 1 schakeling met 4 ingangen en 7 uitgangen zou je kunnen bekijken als 7 schakelingen met ieder 4 ingangen en 1 uitgang. Je kan dat zo implementeren, maar dat geeft meestal geen effici\"ente implementatie.

\paragraph{Slide 25:} Je kan poorten die je in de ene implementatie gebruikt ook voor de andere gebruiken. Het voordeel is dat die maar 1 keer kosten. Zoveel mogelijk poorten hergebruiken is waar we naar op zoek zijn, daarom mag je dat niet onafhankelijk van elkaar maken. Je moet alle kaarten bijeen bekijken en dan als 1 probleem oplossen. Stel dat we enkel priemimplicanten gebruiken. Er is een speciaal soort priemimplicanten, die essenti\"ele heb je zeker nodig. Wat je wel kan doen is die 7 kaarten opstellen en in ieder van die kaarten naar de essenti\"ele zoeken. Je weet dat je die nodig hebt om die ge\"implementeerd te krijgen. Je kan geluk hebben dat er priemimplicanten overeenkomen. Je gaat in iedere kaart de essenti\"ele priemimplicanten zoeken en die al als basisoplossing gebruiken. In het tweede deel, waarin je de resterende enen gaat proberen oplossen, mag je het niet onafhankelijk van elkaar bekijken want ondertussen heb je al poorten ter beschikking en het zou het interessantst zijn om poorten te hergebruiken. Wat in het rood aangegeven is, is in iedere kaart de essenti\"ele priemimplicant. In de eerste twee kom je toe met de ene essenti\"ele die er is, maar bij de derde zijn er nog 2 enen die niet bedekt zijn door de essenti\"ele. De vraag is nu hoe je die gaat realiseren. Nu gaan we ook naar de andere kaarten kijken, want het zou kunnen dat die al in een andere kaart ge\"implementeerd zijn. Dat is al zo: die twee blauwe zijn geen essenti\"ele voor c, maar degene die de middelste implementeert is een essenti\"ele in a en b en de blauwe die de rechtse kolom samenneemt is een essenti\"ele in a. in dit geval bestaan ze beiden al. Als er al meerdere ge\"implementeerd zijn, hoe kies je dan? Qua kostprijs maakt dat op zich niets uit. Je kan kijken naar andere randvoorwaarden zoals bv. een zo snel mogelijke schakeling. Die hangt af (bij CMOS) van de fan-out. Dus, wat ga je hier doen? De schakeling zal zo snel mogelijk zijn als je de fan-out van alle poorten zo laag mogelijk kan houden. Dat betekent dat ze allemaal zo weinig mogelijk gebruikt moeten worden. Je gaat ze gebruiken omwille van de kostprijs, maar je gaat een poort die al veel gebruikt is niet hergebruiken als er een is die weinig gebruikt is. Die van b is al 2 keer gebruikt, die van a (de rechtse kolom) is nog maar 1 keer gebruikt, dus we gaan die gebruiken. Belangrijk is dus dat je dat niet onafhankelijk van elkaar mag bekijken. De uiteindelijke implementatie van de drie uitgangen staat onderaan. Je ziet dat er dingen hergebruikt worden. 

\paragraph{Slide 26:} Wat het moeilijker maakt is wanneer je meerdere kaarten hebt die je samen moet bekijken. Het kan hierbij gebeuren dat, als je meerdere uitgangen hebt, het interessant is om niet-essenti\"ele priemimplicanten te gebruiken, of zelfs implicanten te gebruiken die geen priemimplicant zijn. Normaal is dat geen goed idee, maar dat kan een goed idee zijn als je er meerdere hebt. We hebben hier twee kaarten/uitgangen voor 4 ingangen. We gaan dat implementeren op de manier juist uitgelegd en dan krijg je kostprijs 32. Dit is evenwel niet de meest compacte implementatie. Je kan gebruik maken van niet-essenti\"ele priemimplicanten, maar alleen als ze al ergens anders voor gebruikt werden, alleen als je daardoor hergebruik kan stimuleren (alleen als je meerdere uitgangen hebt, nooit bij 1 uitgang). Bij hergebruik stijgt de kostprijs niet: het maakt dan niet uit als je 1 poort hebt die duurder is maar wel meer gebruikt kan worden.\\ 
Vanonder is men niet op zoek gegaan naar essenti\"ele priemimplicanten, maar is men gaan kijken hoe zoveel mogelijk hergebruikt kon worden. Wat in het groen weergegeven is en de 1 onderaan kan je 2 keer gebruiken. Je kan zeggen dat de 1 bij a niet nuttig is omdat je die kan samennemen met de enen erboven, maar dat zou enkel zijn wanneer je maar 1 kaart hebt, nu gaat dat omdat je meerdere kaarten hebt: het is toch gratis om ze een tweede keer te gebruiken. Bij de twee enen in de derde kolom is geen enkele kaart een priemimplicant, maar je kan het hergebruiken dus uw kostprijs daalt. Het probleem hierbij is dat er geen mooi stappenplan is om dat te vinden. Je moet die kaarten naast elkaar leggen en ernaar beginnen staren en hopen dat er dingen naar boven komen, je gaat misschien dingen moeten proberen. Het is dus trial-and-error. Het probleem is daarmee nog niet helemaal opgelost: alles wat we tot nu toe gezien hebben geldt alleen als je tot een tweelagenimplementatie komt. Daar ben je dikwijls naar opzoek want het is de snelste implementatie, maar in vele gevallen kan het interessant zijn om naar meerdere lagen te zoekn, maar daar heb je ook niet echt mogelijkehden.

\paragraph{Slide 27:} Dit soort technieken is in alle CAD-omgevingen ge\"implementeerd, maar niet met Karnaughkaarten (is een visuele manier van werken). Er is dus een tegenhanger van: Quine-McCluskey. Die maakt gebruik van tabellen. Is niet echt interessant om dat met potlood en papier te doen, zo kan die tot een goede oplossing komen. De technieken die daarachter zitten zoals essenti\"ele priemimplicanten zoeken,\ldots komen daar ook aan bod. We gaan dat niet nog eens zien omdat het niet nuttig is in dit geval. Het staat in het boek in detail beschreven als het u interesseert. Je moet gewoon weten dat het een tegenhanger is van Karnaugh die hetzelde doet.

\paragraph{Slide 30:} Het kan zijn dat nadat je je specificaties geanalyseerd hebt, je dat als logische bewerking op de manier na de slide beschrijft. We kunnen geen poorten maken met een fan-in van 100, dat is niet mogelijk om technologische redenen. Als je dus met die technieken van Karnaughkaarten uitkomt op een poort met 100 ingangen, dan kan je die niet maken. In die technieken van daarnet kan je dat niet inbrengen dat er een beperkte fan-in is. Hoe doe je dat dan? Je lost het probleem in stukjes op: eerst hou je er geen rekening mee, dan ga je kijken hoe je uw poorten kunt realiseren met minder ingangen dan je bent uitgekomen. Het komt erop neer dat je haakjes gaat introduceren: de onderste formuleset is eerst een OR-poort met 4 ingangen en dan reduceer je die naar 3 OR-poorten met 4 ingangen. Je kan uw poorten omzetten naar meerdere lagen van OR-poorten. Je kan de haakjes ook anders zetten en dan krijg je ook poorten met 4 ingangen.  \\
Op zichzelf is die laatste lijn niet slechter dan de voorlaatste (zelfde kostprijs), maar qua vertraging is dat niet hetzelde: in de onderste heb je 3 lagen en die gaat trager zijn. Als we dan toch kunnen kiezen, kiezen we natuurlijk de snelste oplossing. Je gaat altijd een boomstructuur toepassen, dat is de snelste manier van werken. Dat is hier ge\"illustreerd voor OR-poorten, dat geldt evengoed voor AND-poorten en XOR-poorten.  Zo kan je tegemoet komen aan de beperkte fan-in die we soms hebben.

\paragraph{Slide 31:} Functionele ontbinding: de functie ontbinden in verschillende delen die je ieder afzonderlijk gaat implementeren. Bij voorkeur ga je die delen zo kiezen dat de uitgang van het ene deel op meerdere plaatsen kan gebruikt worden, dan heb je iets nuttig apart ge\"implementeerd. Je gaat nadenken van wat erin zit, waaruit bestaat het probleem dat je wil oplossen en wat zijn de subproblemen? Elk van die subproblemen ga je apart implementeren. Dat is typisch wat je doet als je hi\"erarchisch gaat oplossen. Ieder van de subschema's ga je laten invullen. Zelfs als je de subschema's optimaal maakt, gaat het totaal geen tweelagenlogica zijn.\\
Heel dikwijls, zonder het zelf te beseffen, kom je tot meerlagenlogica. We gaan dat straks toepassen. Je komt dan tot een andere (goedkopere) implementatie en gedeeltelijk snellere implementatie. Het probleem hier weer is dat het ook hier niet evident is wat je juist moet gebruiken, wat een goed resultaat zal opleveren. Er is dus heel veel trial-and-error en ervaring begint hier mee te spelen. 

\paragraph{Slide 32:} Alles wat we tot nu toe gezien hebben gaat er vanuit dat we alleen beschikking hebben over basispoorten in een CMOS-technologie. Maar dat is niet het geval, we kunnen ook AND-OR-invert gebruiken. Als je een FPGA gebruikt, doet het er eigenlijk niet toe wat voor poorten je hebt want 1 blokje in een FPGA kan elk van die functies gaan uitvoeren. Hoe los je het probleem nu op? Door technology mapping.

\paragraph{Slide 33:} Je kapt uw probleem in zoveel kleine stukjes die je wel kan oplossen en zet die allemaal samen. We gaan dat hier ook zo doen. Zowel voor FPGA als voor gatearrays. We gaan in 2 stappen werken:
\begin{enumerate}
\item We hebben een beschrijving, we gaan die proberen zo compact mogelijk voor te stellen. We gaan doen alsof we het met basispoorten gaan imlementeren, dan hebben we de meest compacte beschrijving van de functionaliteit die we moeten implementeren.
\item Een keer we dat hebben gaan we dat implementeren, rekening hodend met de beperkingen die er zijn. 
\end{enumerate}	
In praktijk worden we daar meestal bij geholpen want stap 2 is zeer sterk afhankelijk van de implementatie: komt het in een FPGA, in een gate-array,\ldots Degene bij wie we dat gaan implementeren weet dat we met dat probleem zitten en zal daar gewoonlijk software voor leveren om die stap te doen want het is te specifiek voor de implementatie.

\paragraph{Slide 34:} (\textcolor{red}{EXAMEN: je mag alleen NAND en/of NOR poorten gebruiken met 2 ingangen, niet met meer dan 2 ingangen, ook geen AND en OR}). Hoe ga je dan te werk? Je gaat eerst de Karnaugh-technieken toepassen en dan kom je bv. tot de tekening links. Je hebt dan de compactste oplossing gezocht, die moet je gaan omzetten naar een implementatie die met die beperking reking houdt. Het eerste wat je dan doet is die poorten opsplitsen. Daarmee heb je de eerste beperkign opgelost: geen enkele poort die meer dan 2 ingangen heeft. Dan moet je dat omzetten naar NAND en NOR. Op die manier heb je een implemenatie die aan alle beperkingen voldoet.

\paragraph{Slide 35:} We hebben nu gezien dat er heel veel verschillende implementaties zijn, welke is nu de goeie? We kunnen alleen zoveel mogelijk implementaties bedenken en er dan de beste uitkiezen.

\paragraph{Slide 36:} Je kan de canonieke oplossing gebruiken. De canonieke POS is duurder want je hebt meer nullen dan enen.

\paragraph{Slide 37:} Karnaugh toepassen om de minimale SOP te zoeken. Vertraging: kritisch pad, alle poorten zijn hetzelfde en soms moet je door een inverter. 

\paragraph{Slide 40:} Met meer lagen werken, complexe poorten gebruiken,\ldots wat in het blauw gekleurd is is 1 poort: OR-AND-invertpoort. Dat heeft dus 1 kostprijs van 6 en een vertraging van 3.

\paragraph{Slide 41:} In de praktijk is het niet mogelijk om alles te gaan bekijken, er wordt dan meestal gevraagd wat volgens u de beste oplossing zou zijn en te vermelden waarom. Alles nog eens vergeleken: illustreren dat vertraging en kostprijs niet altijd hand in hand gaan. De goedkoopste oplossing is hier niet de snelste oplossing. Het is niet automatisch zo dat de meest compacte oplossing ook de snelste is. Wanneer je het dan moet implementeren moet je weten of snelheid of kostprijs het belangrijkste is voor jou. Afhankelijk daarvan zal je voor 1 van de 2 oplosingen kiezen. Die tabel is geen algemene tabel! Die is anders voor elk probleem dat je moet oplossen, het dient gewoon om te illustreren voor 1 specifiek probleem.

\paragraph{Slide 42:} We weten hoe we combinatorische schaklingen maken en wat de mogelijkheden zijn. Nu moeten we dat op een hoger niveau gaan toepassen. Bij de combinatorische schakelingen heb je niet zoveel mogelijkheden: je hebt een aantal bouwblokken die nodig zijn om berekeningen te doen en een beperkt aantal bassischakelingen die bepaalde dingen doen (bv. kiezen uit 10 mogelijkheden). We gaan eerst kijken naar de rekenkundige basisschakelingen.

\paragraph{Slide 43:} Eerst moeten we overeenkomen hoe we getallen gaan voorstellen. Heel formeel beschreven wat die cijfers te doen hebben met het getal. De plaats van het cijfers bepaalt de radix (met welke macht van 10 je werkt). 

\paragraph{Slide 44:} Wij rekenen normaal niet met het decimale stelsel. Het idee blijft wel hetzelfde. We gaan heel dikwijls niet binair werken omdat het misnte grote getal dat we willen voorstellen een enorme opeenvolging van enen en nullen is, dat kunnen wij niet makkelijk onthouden. Men is op zoek gegaan om een aantal bits samen te nemen en dat als 1 cijfer voor te stellen. De grootste macht van 2 die je voor kan stellen met 1 cijfer is een 8 $\rightarrow$ octaal stelsel. Dit zijn 3 bits, is niet handig om neer te schrijven. Hexadeximaal is veel makkelijker. Daarmee kan je met een beperkt aantal cijfers redelijk grote getallen weergeven.

\paragraph{Slide 45:} Het is ook niet moeilijk om van het ene naar het andere over te gaan, zolang ze eenzelfde basis hebben.

\paragraph{Slide 46:} We gaan daar nu mee rekenen. 

\paragraph{Slide 47:} Herhaling van het eerste leerjaar.

\paragraph{Slide 48:} Halve opteller: kolom s = ``uitkomst" voor die rij/kolom, c is de carry-over. $c_{i+1}$ is de AND van $x_i$ \& $y_i$, $s_i$ is het dambordpatroon. Het is een halve opteller omdat het maar 2 bits kan optellen. Als je overdracht hebt, moet je 3 bits optellen, dus dat hebben we ook nog nodig. 

\paragraph{Slide 49:} De Karnaughkaart wordt hier iets moeilijker.

\paragraph{Slide 50:} We moeten naar kostprijzen gaan kijken. Als je meerdere cijfers moet optellen wordt de snelheid niet bepaald door van de ingang naar de carry te gaan, maar door van de inkomende carry naar de uitgaande carry te gaan. Van $c_i$ naar $c_{i+1}$ is de vertraging van een AND naar een OR. Dit is beter want op de vorige slide was het een AND en een OR-poort met 3 ingaggen.

\paragraph{Slide 51:} Waarom ben je ge\"interesseerd in de inkomende carry naar de uitgaande carry? Als je die cijfers naast elkaar zet krijg je wat te zien is op de slide. Waar wordt hier nu de snelheid door bepaald? Door de langste weg die je hebt: als de carry verandert kan de volgende carry ook veranderen,\ldots Je moet dus van helemaal rechts naar helemaal links geraken en da's het slechtste geval. Vandaar ripple-carry: rimpelt door van helemaal rechts naar helemaal links. Hoe meer carries je hebt, hoe langer het duurt. Als je dus een 4-bits opteller wilt hebben, gaat het een poosje duren voor het meest beduidende resultaat zichtbaar gaat zijn. De vertraging van die opteller is dus evenredig met het aantal bits. We gaan nu 1 grote opteller maken van 8 bits met 17 ingangen en 19 uitgangen.

\chapter{Les 6}

\section{Slides: 4\_Combinatorisch}

\paragraph{Slide 50:} We hebben gekeken hoe we bouwblokken van combinatorische schakelingen kunnen maken. De eerste die we aan het bekijken waren was een opteller. Uiteindelijk waren we ertoe gekomen dat we dat kunnen opdelen in onderdeeltjes: 1 opteller per cijfer en dan kregen we een dergelijke implementatie en die kunnen we combineren naar meerdere cijfers. En dan krijg je wat op \textbf{Slide 51} staat.

\paragraph{Slide 51:} Die werken niet onafhankelijk van elkaar. Via de carry gebeurt de overdracht van de ene naar de andere. Dit zorgt voor vertragingen want wanneer er iets gebeurt moet je wachten tot het doorgerimpeld is voor je zeker kan zijn dat het juiste cijfer bekomen is. Een 32-bits opteller is 2 keer zo traag als een 16-bits opteller en we willen dat nu sneller maken. Dat kan door dat niet mooi gestructureerd zoals hier te implementeren, maar door dat als een grote shcakeling te zien, bv. met 9 ingangen en 5 uitgangen. Het nadeel is dat we niet meer iets kunnen hergebruiken. De vraag is dan ook of er een tussenoplossing is waarbij we wat kunnen hergebruiken maar dat sneller werkt dan de ripple-carry opteller. Er zijn verschillende mogelijkheden.

\paragraph{Slide 52:} Meest courante: carry-lookahead opteller. Wat het meest vertragende was (carry doorgeven) gaan we proberen versnellen. Je kan de dia van \textbf{Slide 50} hertekenen en dan krijg je wat op deze slide staat. Als je die signalen ($p_i$ en $g_i$) hebt, kan je de werking herschrijven zoals getoond op de slide. p en g zijn de signalen voor propagate en generate, met de betekenis op een carry: ik ga in dit cijfer een carry genereren. Wanneer genereer je zeker een overdracht? Wanneer je 1+1 doet, onafhankelijk of er een gepropageerd gaat worden of niet. Wanneer ga je er een voortplanten? Als er 1 aan de ingang is, dan ook 1 aan de uitgang. 1 van de ingangsbits moet 1 zijn (staat in $p_i$). Je kan dat vereenvoudigen, maar nu kunnen we hetzelfde schema behouden. Je kan het verband tussen de uitgaande en binnenkomende carry schrijven als $c_{i+1}$. De carry hangt enkel onrechtstreeks af van $x_i$ en $y_i$ (denk ik). Uitgaande van de 3 ingangssignalen berekenen we de volgende carry die gebruik maakt van die ingangen en p en g. Wanneer we meerdere cijfers hebben gaan we dit gedeelde dat niet in het hokje zit in tweelagen logica implementeren. We zorgen dat de overdracht van de carry in naar de carry out zeer snel gebeurt.

\paragraph{Slide 53:} Die blokjes op de dia genereert de p en de g en de som daarvan. Dat gebeurt nog altijd per cijfer , maar daarnaast heb je nog het doorgeven van de carry. Dat gebeurt in het gele blokje en dat is voor alle cijfers samen. Wat is het verschil? Stel dat 1/meer bits veranderen, dan zullen die blauw/groene blokjes ongeveer tegelijkertijd een p en een g kunnen genereren, daar is 1 vertaging onafhankelijk van welke bit je veranderd hebt. Dan heb je van die p en die g die veranderd is via een tweelagenlogica naar alle carries die er zijn. Die worden allemaal onmiddelijk gegenereerd. Die carry kan dan gebruikt worden om de juiste som te genereren. De totale vertraging heb je dus: door het groen daar propagate en generate, naar de carry en die carry wordt dan nog eens gebruikt om de som te genereren en daar wordt dan de som van genomen. De vertraging hangt nu dus niet meer af van het aantal cijfers. Doordat je aan p en g een betekenis toekent kan je neershcrijven wat er binnenin zit. De vertraging is nu onafhankelijk geworden van het aantal cijfers, maar niet helemaal. Hoe meer cijfers je hebt, hoe groter die producten worden. Je hebt wel tweelagen logica, maar je hebt altijd maar grotere poorten: zoveel ingangen als er cijfers zijn. De vertraging neemt ook toe met het aantal ingangen, dus ingangen blijven toevoegen is ook geen optie.

\paragraph{Slide 54:} Uitgerekend wat de vertraging is: het aantal ingangen zit er nog steeds in, zij het wel met een kleinere factor. Het grootste probleem is dat als je heel veel bits hebt, je dat niet met 1 poort kan realiseren. Dan zal je een boomstructuur van poorten moeten gebruiken. Nog een probleem dat we niet opgelost hebben: de CLA-generator is afhankelijk van het aantal bits (2x zoveel). Wat daarin zit is ook verschillend voor het aantal bits. Als je dat dus wil hebben voor 4 of 5 bits moet je dat anders ontwerpen. Voor elke hoeveelheid cijfers moet je een nieuw ontwerp maken. We kunnen dit oplossen: ervoor zorgen dat we een oplossing hebben waar we redelijk wat kunnen hergebruiken en we toch niet die lineaire toename hebben met het aantal bits. Dat is de schakeling op de slide: elk geel blokje is een CLA zoals op de vorige slide. We gaan die 1 keer ontwerpen voor een vast aantal cijfers, in dit geval voor 4 cijfers. Er komen 4 p's en 4 g's binnen en een carry. Voor 8 bits kunnen we die 2 keer gebruiken, voor 16 bits kunnen we die 4 keer gebruiken. Het is niet zo dat dat onafhankelijk is van elkaar: je moet dat doen zoals op de slide. Eerst worden die samengezet in groepjes van 4, die op hun beurt kunnen in eenzelfde component gestoken worden die de informatie van 16 generates en propagates combineert. Kom je niet toe met 16, leg je nog een laag bij, zo kan je tot 64 gaan. Elke keer je het aantal ingangen verdubbelt, komt er 1 laag bij. We hebben dus een component waarmee we alles kunnen doen. Het is meer hardware dan oorspronkelijk en op zich hebben ze elk geen fan-in probleem, maar er is meer hardware, dus we gaan er meer voor moeten betalen. Wat is de vertraging van dit? We gaan kijken wat het langste pad is: we moeten een aantal keer door de lagen door eer alle carries gegenereerd zijn. Waar zit de vertraging? Die is evenredig met het aantal lagen en dat neemt logaritmisch toe met het aantal bits. Het heeft dus geen constante vertraging maar een logaritmisch stijgende vertraging. Wanneer je dus naar snelheid gaat kijken is dit meestal de oplossing die gekozen wordt.\\
Zelfs voor een opteller bestaan er verschillende ontwerpen. Afhankelijk van wat je belangrijk vindt ga je een ander ontwerp kiezen: als kostprijs belangrijk is kies je bv. voor de ripple-carry, als snelheid belangrijk is ga je eerder kiezen voor de carry-lookahead.

\paragraph{Slide 55:} Als we nu getallen van elkaar willen aftrekken, kunnen we de opteller gebruiken waarbij we negatieve getallen voorstellen. 

\paragraph{Slide 56:} De meest gekende is de sign-magnitude: we hebben een grootte en een teken. Bij conventie is een 0 een + en een 1 een -.

\paragraph{Slide 57:} Je hebt ook complementsvoorstelling: je gaat van ieder cijfer het complement nemen. Als je in het decimaal stelsel werkt, neem je het 9-complement. Bij binair is dat het 1-complement.\\
Radix-complement: als we n cijfers hebben is het radixcomplement $r^n$-D (oorspronkelijk getal). Als je die twee vergelijkt zit er altijd 1 verschil tussen (tussen cijferscomplement en radixcomplement). Dat is geen toeval. Dat heeft ermee te maken dat bij het cijfercomplement van ieder cijfer van 9 afgetrokken werd. Je kan evengoed het volledig getal van 999 aftrekken (want dan zal je nooit moeten gaan lenen). Dat is wat er staat met die D'. Het is belangrijk omdat we dat gaan gebruiken om het radixcomplement te berekenen, dat is veel makkelijker.

\paragraph{Slide 58:} Mooie aan het tweecomplement: in het blauw: we kunnen dat beschouwen alsof het de negatieve voorstelling is. Waarom is dat zo? Als je die definitie boven het blauw hebt, kan je geen onderscheid maken tussen $r^n$ en 0 want $r^n$ is een 1 met n nullen achter, maar als je maar n cijfers hebt, zie je die 1 niet meer, dan is dat hetzelfde want je kan het verschil niet meer maken tussen $r^n$ en 0. Je kan geen onderscheid meer maken tussen het radixcomplement en het negatieve getal. Je kan dat dus evengoed gebruiken als voorstelling van het negatieve getal. Eens je dat doet kan je dat optellen en dan optellen met een negatief getal. 

\paragraph{Slide 58:} Wat als je het omgekeerde nu hebt, hoe weet je dan of dat bv. -3 is of 13? Aan de bitcombinatie kan je dat niet zien: die bitcombinatie kan verschillende dingen voorstellen.

\paragraph{Slide 59:} Bitcombinaties: de interpretatie is verschillend van afhankelijk van welke voorstelling je veronderstelt. Een bitcombinatie op zichzelf zegt niks, je weet niet over welk getal het gaat: unsigned, sign-magnitude,\ldots In veel gevallen gaat dat er niet bijstaan, dan betekent het gewoonlijk het 2-complement, maar het kan er evengoed ergens bijstaan.\\
Probleem op het examen regelmatig: er is een verschil tusesn een 2-compelementvoorstelling (hoe je die bitcombinatie moet interpreteren: 1010 komt overeen met -6) en het 2-complement nemen (je doet een bewerking) dat is iets anders: bij 2-complementvoorstelling komt geen hardware overeen. Bij het nemen van het 2-complement heb je hardware nodig. Je moet dus geen operator er gaan tussenzetten om het 2-complement te berekenen als er staat dat het in 2-complement staat.\\
Als het sign-magnitude is, is de eerste bit het teken. Bij de complementsvoorstelling is het anders: de eerste bit geeft het teken aan, maar om de grootte te kennen moet je het complement nemen: 1000: negatief getal, hoe bereken je de grootte? Door van dat getal het 1-complement te nemen: 0111 = 111 - 7. Bij het 2-complement: 1110: je moet het 2-complement nemen: eerst het 1-complement en er dan 1 bij optellen: 0001 en dan +1: 0010. Bij -8: je komt opnieuw 8 uit en je weet dat het negatief is, dus -8. Bij het 2-complement is er maar 1 voorstelling voor 0, bij het 1-complement zijn er 2 voorstellingen voor 0.

\paragraph{Slide 60:} Ander probleem dat veel voorkomt: als je een voorstelling hebt in 4 bits en je moet dat eerst omzetten naar een voorstelling in 8 bits, hoe doe je dat? Voor unsigned en sign-magnitude is dat makkelijk: gewoon uitbreiden met nullen vooraan. Bij de complementsvoorstellingen is het iets complexer: als het getal positief is, moet je gewoon nullen toevoegen. Als het negatief is, moet je de radix-1 toevoegen. In het geval van bits is dat een 1 toevoegen (denk ik??). Als je een getal wil uitbreiden waarvan je weet dat het in 2-complementsvoorstelling staat, dan moet je gewoon de tekenbit er extra aan toevoegen aan de meest beduidende bits. Als die 0 was: nullen ervoor, als het 1 was: 1 ervoor.

\paragraph{Slide 61:} Als we 2 getallen hebben waarvan er 1/beide negatief kunnen zijn, gaan we eerst kijken naar de tekens. Als die tekens gelijk zijn, is dat het teken van het resultaat. Als de tekens niet aan elkaar gelijk zijn, kan het zijn dat je moet testen op + of - 0. Als ze een verschillend teken hebben, moet je kijken welke van de twee de grootste grootheid heeft. Dat is dus heel wat nadenken, niet gewoon een berekening doen. Afhankelijk van de verschillende gevallen telkens iets anders doen.\\
Een aftrekking doen vergt alleen dat je het teken moet veranderen.\\
Dat neemt niet weg dat je dit normaal niet gaat gebruiken. Als je dit wil implementeren in hardware heb je hardware nodig voor ieder van die testen en voor ieder van die blokjes, ook een controle die afhankelijk van de testen bepaalt welk stukje in gang schiet. Daarom gebruiken we dit normaal niet in computers.

\paragraph{Slide 62:} Als je kijkt naar de \'e\'encomplementsvoorstelling: je telt de getallen op en moet een carry-aanpassing doen. Als er een carry uitkomt, tel je die nog eens bij het resultaat op. Als je negatieve getallen hebt, moet je niet het teken veranderen, maar gewoon het 1-complement nemen. Dat is veel makkelijker met hardware.\\
Nadeel: je hebt 2 stappen: je moet eerst een optelling doen (met ripple carry: vertraging), dan komt daar een carry uit en moet je nog eens een opteling doen $\rightarrow$ dubbele vertraging ten opzichte van gewone optelling.

\paragraph{Slide 63:} Optelling met 2-complement: door de voorstellingswijze is het optellen van een positief of negatief getal hetzelfde. Je neemt gewoon de som en dat blijft hetzelfde. Dit is dus het eenvoudigste. Het nadeel is dat de negatieve waarde berekenen vrij ingewikkeld zou kunnen zijn. Je kan doen wat op de slide staat en dan een 1 bij optelen. Dat is niet zo.

\paragraph{Slide 64:} Illustratie aan de hand van voorbeelden: bovenaan staan de carries. De zwarten zijn normaal. Groene: carry-in van de minst-beduidende opteller. Als je een halve opteller gebruikt, hoef je die niet toe te voegen. Grijze: de carry die eruitkomt. Als je je beperkt tot 4 bits heb je die niet meer nodig en mag je die weggooien. Wat we nu gaan doen om die +1 erbij op te tellen is die bijkomende carry te gebruiken. Die +1 Doen we door de carry-ingang te gebruiken. Zo gaan we met 1 opteller een optelling doen en tegelijk +1 zonder dat we daar extra hardware voor nodig hebben. Dus zowel voor optelling als aftrekking in 2-complement heb je alleen de traditionele manier nodig zoals uitgelegd. Daarom gebruikt men meestal 2-complement.\\
Als je niet het aantal bits verandert, kan je in de problemen geraken (in alle gevallen). Als je de twee grootste getallen met elkaar optelt, krijg je een getal dat je niet meer kan voorstellen: 7+6=niet-voorstelbaar in 2-complement met 4 bits. 13 is dus niet voor te stellen, je hebt een extra bit nodig. Als je dat toch met 4 bits wil doen, hou je dat aantal bits vast. Moesten er toch 2 grote getallen opgeteld worden, wil je kunnen detecteren dat het fout is. Dat kan je doen door dat af te schatten wanneer het resultaat boven de 7 of onder de -8 gaat zijn. Eenvoudige manier: kijk naar de carries. De laatste gebruikte carry en degene die eruit komt die je normaal nooit gebruikt: altijd hetzelfde normaal: altijd 00 of 11. Hier is het verschillend. Het feit dat die verschillend zijn toont dat je een overflow hebt. Je moet dus alleen die 2 bits vergelijken. Dat geldt ook voor negatieve getallen.

\paragraph{Slide 65:} Er is heel veel gemeenschappelijk tussen optelling en aftrekking bij hardware. Je gaat dus veel implementaties hebben waarbij we soms een optelling moeten doen en soms een aftrekking. Je kan dan quasi dezelfde hardware gebruiken. De instructiebit (s) gaat bepalen of er een optelling of een aftrekking gaat gebeuren. Bij optelling ga je optellen zoals de traditionele optelling, aftrekking is door eerst de radix te gebruiken (denk ik?).\\
XOR: als er een 0 opstaat kan je bepalen dat het de x gewoon doorgeeft, als het 1 is, gaat dat x' doorgeven. Je moet die s hangen aan de onderste carry. Als je de overflow wil berekenen, komt er een XOR bij (test of 2 bits verschillend zijn van elkaar of niet).\\
Je kan ook nog een stap verder gaan: nog meer dingen combineren. In plaats van een afzonderlijke optelling en aftrekking te nemen, wil je een stuk hardware dat de ene keer als opteller en een andere keer als aftrekker gebruikt kan worden, dat drukt de kostprijs. Kunnen we dat nog uitbreiden? 

\paragraph{Slide 66:} ALU: 1 component/schakeling dat verschilelnde dingen kan doen: optellingen, aftrekkingen, logische functies of gelijk wat je beslist dat die allemaal moet kunnen.\\
Voorbeeld van een die optellingen en aftrekkingen kan doen. Logische bwerkingen: kan je bit bij bit doen, de bits be\"invloeden elkaar niet. Bij rekenkundige berekeningen be\"invloeden de bits elkaar.\\
Vastgelegd en nu kan je weerom zeggen dat je de specificaties hebt en dat met Karnaughkaarten oplost. Bij complexe dingen is het soms interessant om eerst na te denken en te kijken welke kennis je al hebt. Je kan eerst een uitbreiding doen van het vorige. Hier gaan we dat ook doen. We hebben hier 2 soorten bewerkingen: rekenkundige en logische. Voor de rekenkundige ga je de opteller voorzien. Je kan daar iets bovenzetten: ALE.

\paragraph{Slide 67:} Dan krijg je dit schema. Waarom zo getekend? Die ALE moet zo zijn dat het voor alle cijfers hetzelfde is: je moet het maar 1 keer maken en je kan het n keer gebruiken. Eens je dat vastgelegd heb kan je aangeven of het over een rekenkundige of logische bewerking gaat,\ldots Dan moet je vastleggen wat er gaat uitkomen, dat is die F-kolom. Omdat het we het bovenstaande schema al kennen, kunnen we zeggen wat X en Y moeten zijn. Alle logische bewerkingen gaan in de extender gebeuren en alle rekenkundige bewerkingen, daarvoor gaan we zorgen dat die op de juiste manier gebeuren zoals gedefini\"eerd.\\
De extender gaan we wel met Karnaughkaarten doen.

\paragraph{Slide 68:} Elke rij in de tabel komt overeen met een kolom bij de Karnaughkaarten. (denk ik). Je moet dan de (essenti\"ele (priem))implicanten gaan zoeken.\\
Snellere manier hierop toepasen: eerst de enen op ge\"isoleerrde plaatsen zoeken. Bv. de rood omcirkelde: valt niet met iets anders te combineren. De eentjes boven het vierkant rechtsonder ook. Je veronderstelt dan dat dit de enige goede oplossing is. Let er wel op dat je altijd de grootst mogelijk oplossing moet zoeken. -1 betekent een 1 voor elk cijfer.

\paragraph{Slide 69:} We gaan kijken hoe we een vermenigvuldinger kunnen implementeren in hardware.

\paragraph{Slide 70:} De manier van werken is hetzelfde. We gaan elk cijfer in de tweede rij vermenigvuldigen met het cijfer erboven, dat genereert een parti\"eel product en zo voort en dat tellen we dna op. Dat is een iteratief proces, ook bij hoe wij dat doen. Je kan dat in hardware ook op een iteratieve manier implementeren. Je moet lang wachten tot je uw resultaten hebt. De vraag is of dat sneller kan. Vermenigvuldigen met $2^n$ is er n nullen achterzetten, gewoon opschuiven: heel eenvoudig te doen.\\
Ook het meer algemene geval is nog te doen: we moeten die parti\"ele producten berekenen en dan optellen. Die parti\"ele producten zijn onafhankelijk van elkaar. Je kan die dus in parallel berekenen, je moet er alleen veel hardware tegenaan gooien.

\paragraph{Slide 71:} Wat betekent dat? Tafels van vermenigvuldiging voor het binaire geval. Als we meer-bits getallen hebben, bv. 2-bits: $a_0b_0$ en dat geeft het parti\"ele product. Het volgende is juist hetzelfde. Dan moeten we dat nog optellen. Je zou denken dat we een 4-bitsopteller nodig hebben, maar dat is niet zo want die eerste bit moet nergens bij opgeteld worden, pas vanaf de tweede bit. En de laatste is de carry die erbij opgeteld wordt. We moeten dat wel nog aanvullen met een 0.

\paragraph{Slide 72:} Meer algemeen, bv. 4x3-bit: de grootte van de schakeling/het aantal transistoren dat je al nodig hebt is een functie van het product van de bits van de getallen, bij 4x3 is dat dus 12. Als je naar grote getallen gaat worden die vermenigvuldigers zeer snel zeer groot.

\paragraph{Slide 73:} Voor andere voorstelling zoals 2-complementsvoorstelling: de meest linkse bit is de tekenbit. Als je 1111 schrijft als machten van 2 is de meest linkse bit -8 en niet 8. Dat laatste is niet gewoon uitbreiden met tekenbits want dat zou 8x-1 geven. Je moet gaan kijken wat je moet doen. Het is dat soort zaken dat ervoor zorgt dat een vermenigvuldiger maken voor een 2-complement maken moeilijker is dan voor natuurlijke getallen. Dat is ingewikkelderder. In sommige gevallen levert het op om eerst van 2-comlement naar sign-magnitude te gaan en daarmee te rekenen en dan terug te gaan.

\paragraph{Slide 75:} Delen: het grote verschil lis dat hier gen parti\"ele producten zijn die onafhankelijk zijn van elkaar, hier moet je eerst kijken of de deler in de eerste X getallen van het deeltal geraakt. Bijna de enige manier om vermenigvuldigingen te doen is op een iteratieve manier. De meesten werken ook iteratief. Zelfs als je er heel veel hardware tegenaan gooit, zelfs dan zijn ze nog traag. Daarom willen we delingen zoveel mogelijk vermijden in de hardware, tenzij het een deling door een macht van 2 is want dan moet je gewoon opschuiven: minst beduidende bit weglaten. Alle anderen zijn ingewikkeld en ga je vermijden. Als je dat toch probeert op het examen, moet je dat ook kunnen verantwoorden op het examen.

\paragraph{Slide 76:} Modulorekenen: rest bij deling: eerst delen en dan rest bepalen. Dat is nog ingewikkelder dan een deling, dus dat ga je ook niet in hardware doen, behalve wanneer de deling makkelijk is zoals bij 2. De modulo van een macht van 2 is ook makkelijk. Bij VHDL heb je er 2 soorten: het bovenste en de remainder.\\
Wij zijn gewoonlijk ge\"intereseerd in modulo en niet in de remainder.\\
Als we modulo van een macht van 2 doen, dan is dat gewoon zoveel bits overhouden. Als je modulo 8 ($2^3$) doet, moet je gewoon de 3 minst beduidende bits overhouden. Je moet zelfs niet weten of dat 1- of 2-complement is of sign-magnitude. Dit kost dus qua hardware niks, je verbindt gewoon de n minst beduidende bits door.

\paragraph{Slide 77:} We hebben basisbwerkingen gehad die we makkelijk in hardware kunnen uitvoeren. Nu gaan we komma's introduceren. Normaal spreken de meeste mensen direct over de vlottende kommavoorstelling. 

\paragraph{Slide 78:} In hardware met vaste komma werken is hetzelfde als met gehele getallen werken omdat een komma met niks in hardware overeenkomt: in hardware is de komma-interpretatie iets imaginair. Je doet dat in het normale rekenen eigenlijk ook zo: 2 kommagetallen met elkaar vermenigvuldigen: eerst doen alsof die er niet stonden, met elkaar vermenigvuldigen en dan de komma plaatsen. Hetzelfde gebeurt in hardware met vaste komma. Je moet gewoon bijhouden waar de komma terecht gaat komen. Voor de hardware zelf maakt dat totaal niks uit.\\
Wat wel belangrijk is: als je 2 kommagetallen met elkaar optelt/vermenigvuldigt, in wat resulteert dat: hoeveel bits en waar staat de komma? Je moet in gedachten houden hoe je 2 kommagetallen optelt: zo boven elkaar zetten dat de komma's boven elkaar staan en dan doe je de optelling. Je moet 1 van de 2 dus misschien wat verschuiven: nullen toevoegen aan de achterkant, dat is wat op de slide staat. Die voor de komma, daar komt 1 bit bij, dat is nodig om te zorgen dat je in geen enkel geval zorgen moet maken over overlfow.\\
Tussendoor: hoeveel bits heb je nodig om dat resultaat correct te kunnen voorstellen? 8 bits (lijkt in tegenspraak met dat van daarnet): de regels gaan eravnuit dat alle mogelijke waarden kunnen optreden. Om echt te weten wat je moet doen, moet je kijken waartussen $\alpha$ kan vari\"eren: tusesn 0 en 15. 17*$\alpha$ kan vari\"eren tussen 0 en 17 keer 15. Dat is dus allemaal voorstelbaar met 8 bits.\\
Stel dat je 4 8-bits getallen moet optellen. Je zou denken dat er met elke optelling 1 bijkomt, maar dat is fout: zie Figuur \ref{les06_01}.

\begin{figure}[ht!]
\centering
\includegraphics[width=30mm]{les06_01.png}
\label{les06_01}
\end{figure}

Je hebt genoeg aan 10 bits. Waarom klopte dat van die 11 niet: zie Figuur \ref{les06_02}.

\begin{figure}[ht!]
\centering
\includegraphics[width=30mm]{les06_02.png}
\label{les06_02}
\end{figure}

\paragraph{Slide 80:} Vlottende komma: totaal anders. Tekenbit, exponent en mantisse. Waarom in die volgorde? Als we hardware kunnen hergebruiken, doen we dat graag. Stel dat je hardware hebt om gehele getallen te behandelen en je wil die gebruiken om ook vlottende kommagetallen met elkaar te vergelijken. Die moeten er dan een beetje hetzelfde uitzien. Dat betekent dat de tekenbit helemaal links moet staan want is bij gehele getallen ook zo. Eens je meer naar rechts gaat, hoe minder beduidend uw cijfer is, hoe minder belangrijk het is. Als je twee getallen vergelijkt ga je eerst kijken of de hoogste cijfers verschillend zijn of niet en als die verschillend zijn ga je bepalen welk van de twee het grootste is. Wat het meeste impact heeft op de grootte staat rechts, dus dat moeten we hier ook doen want de exponent is belangrijker dan de mantisse.

\paragraph{Slide 81:} NaN is het enige getal dat niet gelijk is aan zichzelf. Wanneer je naar hardware-implementaties kijkt gebruikt men meestal het IEEE-formaat, maar alleen de genormaliseerde voorstellingen eravn. Er zijn implementaties die naar niet mee overweg kunnen. De exponent kan zowel positief als negatief zijn. Hier wordt een heel speciale voorstelling gebruikt: excess-formaat: je gaat bij de exponent een getal bijtellen zodanig dat het altijd positief is. Waarom niet als bv. 2-complement? Zou makkelijker zijn tot je de hardware wil gebruiken om te vergelijken. Als we er altijd iets bij optellen zodanig dat het zuiver positief is, geldt het weer want dan hebben we geen tekenbit meer bij wijze van spreken. Daarom wordt er zoiets speciaals gebruikt: je telt het op op het moment dat je stockeert, wanneer je het gaat interpreteren moet je dat er terug van aftrekken.

\paragraph{Slide 82:} Optellen: eerst de exponenten gelijk maken, dan optellen, dan normaliseren. Dat zijn dus heel wat bewerkingen. Dat betekent dat dit ook nog meer hardware vergt voor vlottende komma dan voor gewone bewerkingen (gehele getallen of vaste komma). Je gebruikt dus vaste komma indien mogelijk. Vermenigvuldiging is makkelijker qua stappen dan optellen omdat je de mantisses gewoon met elkaar kan vermenigvuldigen en de exponenten met elkaar kan optellen. 

\paragraph{Slide 83:} Speciale gevallen: als je geen getal wil voorstellen, maar bv. symbolen.

\paragraph{Slide 86:} ASCII: hoe voorstellen?

\paragraph{Slide 84:} BCD: voor elk decimaal cijfer voorzie je 4 bits. Je gebruikt dus maar 10 van de 16 mogelijkheden. Die anderen kunnen en mogen nooit voorkomen. Je moet niet veel bewerkinegn doen op getallen: je hebt een decimale invoer en je wil 2 getallen optellen: van decimaal naar binair en terug is moeilijker. Je kan een opteller ontwerpen die BCD-getallen optelt.

\paragraph{Slide 85:} Je kan het complement berekenen, dat is dan niet het 2-complement maar het 10-complement.\\
Hoe begin je hieraan? Niet met een Karnaughkaart, je begint met na te denken. Als we 2 cijfers willen optellen: een gewone optelling. 10: niet meer voor te stellen met 1 cijfer, ook 7+6. Je moet terug van het cijfer dat binair 13 voorstelt moet je 10 aftrekken en een carry genereren naar de volgende. Wat nu in woorden gezegd is geweest kan direct getekend worden zoals te zien is op de slide. 

\chapter{Les 7}

\section{Slides: 4\_Combinatorisch}

\paragraph{Slide 87:} We gaan de bouwblokken bekijken die we met combinatorische schakelingen kunnen maken. Er zijn nog een aantal bouwblokken die heel veel gebruikt worden, die gaan we nu zien. Buiten de rekenkundige zijn de meest belangrijke bouwblokken die om te kiezen tussen 2/meer waarden: selector of multiplexer.

\paragraph{Slide 88:} We hebben een aantal ingangen met een aantal instructie- of controlebits. We gaan er een kiezen en die doorgeven naar de uitgang. Er is altijd 1 uitgang. Die S bepaalt welke van de ingangen je kiest. Het is weergegeven in een pseudo-waarheidstabel. Deze beschrijft dat voor die 4 selectie-ingangen, wat er op de uitgang komt, het beschrijft het heel goed, is wat overzichtelijker. Het voordeel van die beschrijving is dat je bijna onmiddelijk ziet hoe het ge\"implementeerd kan worden. Je kan detecteren met die 4 AND poorten en als die AND-poort 1 is ga je de ingang doorgeven aan de uitgang. Dat gebeurt door dat te combineren met die AND-poort en dan alle resultaten door te geven naar de uitgang. Weerom zie je dat er een heel algemene techniek is zoals Karnaughkaarten, maar meestal ga je die niet gebruiken want door te redeneren weet je meestal wel wat een goede oplossing is.

\paragraph{Slide 89:} Cascaderen = een basiscomponent meerdere keren gebruiken om zo iets ingewikkelders te doen: n-bit opteller, daarvoor gebruik je n keer een 1-bit opteller. Je hebt 4 selectiebits en de onderste kiest uit 1 van de 4 groepjes en binnen elk groepje kies je uit de minst beduidende bits om te kiezen.\\
Voordelen: je hebt hier veel meer hardware voor nodig dan dat in 1 keer te maken, maar dat is niet waar. De vertraging lijkt ook groter (door 4 lagen gaan), maar raar genoeg is dat niet waar. Het heeft alleen maar voordelen eigenlijk, te zien op de slide. Je kan componenten hergebruiken, je moet alleen maar een 4 naar 1 voorzien en daaruit kan je die anderen opbouwen. Een van de problemen als je heel grote multiplexers wil maken (bv. 16 naar 1), naarmate je meer selectiebits hebt, ga je meer ingangen aan die poorten nodig hebben, die poorten worden groter en groter. Dat heeft tot gevolg dat ze kostelijker worden en dat ze trager worden. Vandaar dat als je dat gaat bekijken, te grote poorten kunnen we niet maken, met deze implementatie heb je geen fan-inproblemen. Het is ook goedkoper en sneller: een poort van 16 ingangen is heel traag, maar wat blijkt: 2 poorten na elkaar zetten van 4 ingangen is sneller dan 1 poort van 16. 2 lagen gebruiken is sneller dan 1 laag in dit geval. Als je dat gaat uitrekenen zie je dat een 4-lagen netwerk is dan een tweelagennetwerk. Daarom wordt cascaderen vaak gebruikt.\\
Het is niet altijd goedkoper en sneller! Soms is het goedkoper maar niet sneller. Maar in dit specifieke geval is dat wel zo.

\paragraph{Slide 91:} Decoder: een aantal bits en die gaan bepalen welke van die $2^n$ uitgangen 1 is en de rest is allemaal 0. Om te cascaderen is er die 0, als die 0 is, is alles 0. De implementatie op zichzelf is ook vrij eenvoudig, is rechtstreeks toe te passen. Komt veel voor als adresdecoder bij geheugens. a is het adres en dat wordt gedecodeerd naar een van de uitgangen. Afhankelijk van welk adres aan de uitgangen ligt, wordt er bepaald welke geheugencel gebruikt wordt.

\paragraph{Slide 92:} Je kan de inverse gaan zoeken, een demultiplexer: je hebt 1 ingang en je stuurt die naar een van de uitgangen. Ook dat kan je cascaderen: je decodeert eerst de meest beduidende bits, die bepaalt dan welke van die 4 actief is en op basis van daarvan ga je verder decoderen.

\paragraph{Slide 93:} De decoder kan ook gebruikt worden om een multiplexer te implementeren: MUX kiest uit 4 ingangen en je kan dat zien als het kiezen van 1 van de 4 en dan de desbetreffende doorgeven. Als je het implementeert zoals op de slide (links) is het wel niet effici\"enter dan wat we eerst deden. Je kan dit wel gebruiken om tot een andere implementatie van de multiplexer te komen: er zijn altijd 2 mogelijkheden om dat te maken: met een echte MUX of met een bus en tristate buffer. Dit is wat weergegeven is rechts. Je gaat het echt doorgeven met de tristatebuffer. Je mag dan de uitgangen aan elkaar hangen want je hebt de garantie dat er altijd maar 1 is die inderdaad ook verbonden is met de bus, de anderen zijn losgekoppeld. Dat is een alternatieve implementatie voor een MUX. Is dit nu compacter? Nee $\rightarrow$ andere manier is dan beter. Toch zijn er soms heel wat redenen om het wel op die manier te doen.

\paragraph{Slide 94:} Grote voordeel: gedistribueerde versie van de MUX kan gemaakt worden: staat niet ergens op 1 plaats in de schakeling, wordt verdeeld over de ganse schakeling. Wat je evengoed kan doen is die tristate buffers verdelen over uw schakelingen, over de systemen die in uw systeem zitten. $\rightarrow$ Computer: je kan borden bijsteken die extra functionaliteit bieden. Er is iets nodig dat zorgt dat er altijd maar 1 van de modules maar informatie op de bus kan zetten.\\
Ze staan dus niet allemaal op dezelfde plaats: per bord/subsysteem heb je 1 tristate buffer.\\
Voordeel: heel makkelijk uit te breiden: als je er een kaart wil bijsteken: gewoon tristate buffer bijzetten, de hardware van de andere kaarten verandert daardoor niet, het is niet zo dat je plots een extra OR-poort nodig hebt. Je kan hier ook nooit fan-in problemen mee krijgen: je kan er zoveel bijsteken als je wilt. Dat geeft een enorme flexibiliteit. Dat is dikwijls de reden om geen MUX te gebruiken maar zo'n systeem.\\
Specifiek voor de FPGA: die tristate buffers zijn niet zo goedkoop, maar bij een FPGA staan er toch nog bij. Bij een FPGA zijn die meestal gratis en je moet er dan geen logische cel voor kopen.

\paragraph{Slide 85:} Van 1 naar $2^n$ $\rightarrow$ 1 ingang wordt doorgegeven naar een van de $2^n$ uitgangen en met de demultiplexer ga je bepalen naar welke uitgang het gaat.\\
Dit is hetzelfde als een decoder, maar waar je bij een decoder zegt dat het de ingangen zegt, dat zijn daar de selectors en waar je bij decoders een enable heb is dat bij de demux de data.

\paragraph{Slide 96 (HEEL BELANGRIJK):} Als je denkt dat je een demux nodig hebt, denk daar nog eens goed over na, omdat in het merendeel van de gevallen je geen demux nodig gaat hebben, is meestal pure verspilling en gaat de hardware niet vooruithelpen.\\
De gele tekening is meestal het geval dat je nodig denkt te hebben: info die naar verschillende gebruikers (niet gelijktijdig) gestuurd moet worden. Als je in een waarheidstabel ingeeft zie je dat de data ofwel naar de ene of wel naar de andere uitgang gaat gaan. Wat er  op de andere plaatsen gebeurt is voor jou eigenlijk niet belangrijk (veel mensen denken van wel). Wat wordt er dan doorgegeven? Niet niks! Je mag uw draden ook niet zwevend laten hangen want dat zorgt voor problemen. Wat geef je dan wel door? Het kan u niet zoveel schelen, maar hardware werkt altijd! Je kan er evengoed iets anders opleggen dan een zwevende ingang, vandaard don't care's. Er zullen berekeningen mee gebeuren en als je dat laat veranderen wordt er meer vermogen gebruiken, maar dan is dat maar zo: is hardware en er staat spanning op, dus er gaat iets mee gebeuren. Zet er dus zeker geen Z.\\
Als we dit gaan implementeren moeten we met die don't care's iets gaan doen, die gaan invullen. Wat misschien het makkelijkste is om te doen is die 0 maken, want dan kom je uit bij de demux. Waarom zou je dat invullen met die nullen? Want het is een don't care. Slimmer is om het in te vullen met D en dan krijg je de waarheidstabel rechts onder. Dat implementeren komt met de tekening linksonder overeen. Als die het even goed doet als met de demux, waarom zou je dan hardware gebruiken? Als die 2 qua werking equivalent zijn, gebruik dan geen demux. Het is niet helemaal hetzelfde als daar een schakeling staan hebben, maar het werkt even goed.

\paragraph{Slide 98:} Encoder: je hebt $2^n$ ingangen en n uitgangen, je wil het getal uitkomen dat met het nummer van de uitgang overeenkomt. De $f_0$ en $f_1$ geven de plaats aan waar die 1 was.\\
We zijn meestal hier niet in ge\"ieteresseerd want je hebt meestal niet de garantie dat er maar 1 1 op de ingang staat, er kunnen ook 2 enen op staan. Dan zou dat niet meer werken! In de praktijk heb je dus de prioriteitsencoder waarbij er wel meerdere ingangen 1 mogen zijn. Je gaat altijd eerst naar de meest beduidende kijken en je neemt dan de eerste 1 die je tegenkomt, de rest maakt u al niet meer uit: als $d_3$ = 1, dan maken $d_2$,\ldots, $d_0$ u niet meer uit.\\
Om te normaliseren moet je vinden waar het eerste beduidende cijfer staat in uw resultaat, hier kan je dat parallel doen: het nummer van demeest beduidende bit komt er hier uit.

\paragraph{Slide 99:} Ook dat kan je cascaderen: dezelfde component hergebruiken. Hier is het niet echt dezelfde component gebruiken, maar een aantal basiscomponenten die je hebt voor een zekere grootte gebruiken: prioriteit decoderen: in groepjes onderverdelen, dan kijken of er een 1 zit in die groep en dan bepalen voor welke er een 1 moet uitkomen. 

\paragraph{Slide 101:} Hoe doe je vergelijkingen? Hoe vergelijk je 2 getallen met elkaar?\\
We gaan ook hier proberen modulair te werken en hardware te hergebruiken. We gaan weer een component maken die 2 cijfers vergelijkt en dat gebruiken om 2 getallen te vergelijken.\\
Je hebt eerst een tabel die 2 bits vergelijkt: $x_1$ en $x_0$ is ons eerste getal, $y_1$ en $y_0$ is het tweede getal. Aan de uitgang zijn er twee uitgangen die aangeven of x groter is dan y of kleiner. Als het noch groter noch kleiner is, dan zijn ze geijk aan elkaar.\\
Als die meest beduidende bits hetzelfde zijn, dan is het de minst beduidende bit die zal bepalen welke van de twee het grootste is.\\
Als die meest beduidende bits verschillen, dan bepalen die welk getal het grootst is, niet de minst beduidende bits. Bij $y_1$ = 1 en $x_1$ = 0, dan zal getal 2 altijd groter zijn dan getal 1. Dat is een belangrijk principe dat we later gaan nodig hebben om die aan elkaar te hangen. Een keer we die waarheidstabel hebben is het makkelijk om er een Karnaughkaart van te tekenen en dat op te lossen en de twee logische functies te bepalen waarmee het ge\"implementeerd kan worden. Als het de meer beduidende bit is die verschilt, bepaalt die het resultaat, anders de minst beduidende bit. Je kan dit veralgemenen: getal in 2 stukken opdelen: meer beduidend gedeelte (als dit verschillend is, bepaalt dit het verschil) en het minder beduidende gedeelte.

\paragraph{Slide 102:} Als $x_7$ en $y_7$ verschillen bepalen zij wat het resultaat zal zijn, anders zal het deel erna bepalen wat bepalend is. Je kan die component van \textbf{Slide 101} dus hergebruiken waarbij de minder beduidende bits weergegeven worden door andere comparators.\\
Vereenvoudiging: die $x_0$ en $y_0$ kunnen 4 mogelijke waarden aannemen, G en L kunnen maar 3 mogelijke waarden aannemen. Telkens waar er 1 1 staat moet er don't care staan (dus $x_0$ en $y_0$ gelijk aan 0). Dan wordt dat deel van de Karnaughkaarten ook vervangen door don't cares en vallen er termen weg in het resultaat.\\
We gaan dat in de praktijk niet doen om dezelfde reden: bij een opteller kan je de minst beduidende optelling door een halve opteller vervangen (denk ik).\\
Deze manier van aan elkaar schakelen, daarmee kan je de vergelijking doen. Probleem: vertraging: als er aan het minst beduidende deel iets verandert moet dat weer helemaal doorrimpelen naar links. De vergelijking is rechtevenredig met het aantal cijfers. We kunnen hier in een boomstructuur werken, want we werken met meer en minder beduidende delen. Je kan dat ook zo opsplitsen zoals te zien is op de slide onderaan. Boomstructuren zijn interessant omwille van de vertragingen want nu is het evenredig met het logaritme van het aantal cijfers.

\paragraph{Slide 103:} Speciale gevallen: het treedt hier het meeste op. In veel gevallen wil je niet zomaar vergelijken. Dit is helemaal niet efici\"ent: comparator per cijfer. Het kan veel compacter. Moraal van het verhaal: wanneer 1 van die gegevens (voor vergelijker, opteller,\ldots), als dat een constante is bestaat er een compactere implementatie. Je kan dit in rekening brengen bij het ontwerp.\\
Wat we heel dikwijls willen doen is testen of 2 getallen aan elkaar gelijk zijn. Je kan dat beter doen met iets dergelijks zoals op de slide vanboven: die kijkt of 2 bits aan elkaar gelijk zijn (XNOR). We gaan dat per bit bekijken en de getallen zijn aan elkaar gelijk als alle bits aan elkaar gelijk zijn. Dit is een veel compactere implementatie dan een comparator. Bv. testen of een getal gelijk is aan 0: 1 enkele NOR-poort. Zodra er een 1 binnenkomt, zal er aan de uitgang een 0 komen te staan. AND-poort: testen of je aan uw grootste waarde zit. Ook andere dingen, als het een combinatie is, die getallen, van machten van 2. Eenvoudigste hardware: testen of iets (on)even is: als het oneven is, is de minst beduidende bit een 1, daarvoor heb je geen hardware nodig. Om te testen of het even is, moet je er een NOT-poort bijzetten. Je kiest dus beter om te testen op onevenheid.\\
Als je wil testen van 10 naar 1. Om te testen of het 0 is is veel makkelijker. Dat soort zaken moet je dus zeker in gedachten hoduen.

\paragraph{Slide 105:} Schuifoperaties: je hebt verschillende manieren om bits te schuiven. Het eenvoudigste is roteren: ofwel naar links ofwel naar rechts schuiven. Wat doe je met de bits die eraf vallen? Je zet die op de vrijgekomen plaatsen. In het andere geval moet je vastleggen wat er moet gebeuren met die vrijgekomen plaatsen, de afvaller ben je kwijt. Het hangt af van welke betekenis je geeft aan uw combinaties van bits. Je wil waarschijnlijk controle hebben over wat er op die plaatsen komt. Als dat een getal is heeft dat een betekenis en kan je er niet zomaar iets willekeurig zetten. Afhankelijk van welke voorstelling je gebruikt van getallen ga je iets anders moeten doen. De bedoeling is natuurlijk dat het getal zijn betekenis blijft behouden. Wat betekent dat nu? Als je de meest beduidende bit laat vallen komt er op de minst beduidende plaats een plaats vrij. Er komt dan een 0 bij.\\
Als het aan de meest beduidende bit een plaats vrij krijgt, hangt het af van de voorstellingswijze die je gebruikt. Een getal uitbreiden hangt af van zijn voorstelling: als het unsigned is komt er een 0 bij, als het een 2-complement is, is het de tekenbit die herhaald wordt (als de tekenbit een 0 was, komt er een 0 bij, anders een 1).

\paragraph{Slide 106:} We gaan zo'n stuk hardware maken dat naar links of rechts kan schuiven of roteren over maximaal 1 plaats. Er is 1 instructiebit die aangeeft of er geschoven wordt of niet, een die aangeeft of dat naar links of rechts gebeurt en een die aangeeft of er geschoven of geroteerd wordt.\\
De 3 bovenste lijnen zijn de ingang en ga je doorgeven aan de 4 plaatsen aan de uitgang. 4-naar-1 multiplexers: 2 ingangen zijn onmiddelijk doorverbonden: als je niet shcuift, maakt het niet uit of het naar links of rechts is: als $s_2 $0 is, is $s_1$ don't care, dat is opgelost zoals te zien in $y_0$. Het is pas wanneer die bit 1 is dat we gaan schuiven, in het ene geval naar links. Op de minst beduidende hangt het ervanaf wat je wilt doen: ofwel roteer je, ofwel is het schuiven en dan moet je bepalen hoe je die invult. Afhankelijk wat vanboven staat is dan aangegeven wat er gebeurt. R = arit'* $R_{in}$: als het geen rekenkundige voorstelling is (niet voorgesteld als een getal) dan is het (???), anders is het altijd 0.\\
L: ???\\
Soms wil je onmiddelijk over 3 of 4 plaatsen schuiven: bv. vlottende komma normalisatie. Als je 10 plaatsen moet opschuiven ga je geen 10 van die hardwaredingen achter elkaar zetten, maar op \textbf{Slide 107}.

\paragraph{Slide 107:} Als je maximaal 16 plaatsen moet opschuiven: 16 muxen die kunnen kiezen welke bits gekozen worden. Er zijn een aantal controlebits die zeggen hoeveel plaatsen je moet opschuiven.\\
Fan-inprobleem: je kan eerst bv. 2 plaatsen opschuiven en daarna 4 of eerst 4 en daarna 2,\ldots: er zijn 8 soorten mogelijkheden om op te schuiven.

\paragraph{Slide 108:} We gaan kijken hoe we de afgelopen zaken in VHDL kunnen beschrijven. We gaan de verschillen tussen de hardwaretaal en een gewone taal bekijken. De syntax moet je niet leren, je krijgt een appendix op het examen. 

\paragraph{Slide 109:} Commentaar weergeven: --, namen geven: let op: geen verschil tussen grote en kleine letters! Letters en cijfers en underscores mogen, mag niet met een underscore eindigen. Getallen voorstellen: op de normale manier. Je kan ook exponenten gebruiken (betekent niet automatisch dat het over vlottende komma gaat!). Wanneer het niet nodig is om vlottende komma te gebruiken, zal VHDL ervan uit gaan dat het vaste komma is. Je kan ook met verschillende basissen werken, moet niet binair. 2\#1\#E10 = 1*$2^10$.

\paragraph{Slide 110:} Je hebt karakters tussen enkele quotes, karakterreeksen en bitreeksen: geef je weer op enzelfde manier als een karakterreeks. Verschil: staat een bepaalde letter voor: O (octal), b (binair), X (hexadecimaal). Hoofdletter of kleine letter ervoor maakt niet uit. Een bitreeks stelt geen getal voor, is gewoon een collectie van bits, zoals een karakterreeks niet per s\'e een woord of zin is.\\
Links en rechts van de pijl zijn niet aan elkaar gelijk, hebben niks met elkaar te maken!

\paragraph{Slide 112:} Wat voor objecten kunnen we gebruiken:
\begin{itemize}
\item Constante: om het programma leesbaar te houden, zijn vaste getallen. 	
\item Variabele: op dezelfde manier als in een softwaretaal. Ook die worden gedeclareerd en hebben eventueel een initi\"ele waarde en je kan er berekeningen op doen. 	
\item Signaal: daar hechten we een hardwarebetekenis aan, aan een variabele niet. Als je iets hardwarematig wilt doen zegt een variabele niks, aan signalen hangt een hardwarebetekenis. Die komen bij wijze van spreken overeen met een draad. In het voorbeeld: y stelt een draad voor: die naar (van) de AND-poort. Je kan het ook gebruiken voor golfvormen. Je ziet het onmiddelijk in het gebruik en de toekenning is ook anders. 
\end{itemize}

\paragraph{Slide 113:} Types: de gewone types met de speciale dingen die je voor hardware nodig hebt: gehele getallen (bij VHDL minstens 32 bit). We moeten exact kunnen aangeven wat de range is.\\
Bit is 0 en 1, is niet hetzeldfe als true en false, maar wordt wel voorgesteld als karakters!\\
Bij simulatie is de tijd ook belangrijk.

\paragraph{Slide 114:} Voorbeeld van een fysisch type. Daar geef je de eenheden aan. Tijd wordt voorgesteld als een geheel getal. De basistijdseenheid is 1 femtoseconde. Dit is niet altijd handig, daarom kan je bij de specificatie ineens verdere dingen defini\"eren.\\
Met zo'n kleine tijdsresolutie werken heeft zijn effect: het grootste tijdsinterval is 4ms als je met XXX bits werkt 32 of 16). Als je met reactie van buitenuit wil rekening houden kan het ms of s duren. Als je met 64 bits werkt geraak je al wat verder. 

\paragraph{Slide 113:} Eenheden samennemen in vectoren en matrices en je kan ook subtypes nemen. Je kan ook types gebruiken. VHDL zal nooit toelaten dat je ervanuit gaat dat zaken aan elkaar gelijk zijn als ze niet van hetzelfde type zijn (bv. kommagetallen en gehele getallen). Een manier om dat op te lossen is door subtypes te gebruiken. Die high: hoogste waarde van een geheel getal.

\paragraph{Slide 115:} Je kan dat samenzetten in vectoren en matrices. Je hebt niet alleen de traditionele vectoren en matrices, maar ook de onbegrensde types. De normale (begrensde), daar leg je het bereik van de indices vast. MSB: most significant bit; LSB: least significant bit.\\
Onbegrensd: vectoren of matrices waarbij je het bereik niet aangeeft, je zegt enkel dat het een geheel/natuurlijk getal is. Daar kan je op zichzelf niets mee doen maar het laat u toe om het geheel op te splitsen: je defini\"eert een type zonder te zeggen hoe groot het moet zijn en dan defini\"eer je een type waarvan je zegt hoe groot het moet zijn.

\paragraph{Slide 116:} Toekenningen in vectoren of matrices. Voor die karakterreeksen/bitreeksen kan je dat als een geheel voorstellen. In het algemeen is het zo dat als je een vector hebt (op de slide van 3 gehele getallen) en je doet een toekenning, als je er voor de rest niks bijzet is het van links naar rechts. Je mag ook namen geven en expliciet zeggen wat op welke plaats komt (onderaan). Het wordt heel dikwijls gebruikt op de manier op de onderste lijn: zet alle bits op 0. 

\paragraph{Slide 117:} Bits worden met 0 en 1 voorgesteld, maar we moeten ook zwevend en tristate kunnen aangeven. Je kan dat uitbreiden: std\_logic: nieuw type.
\begin{itemize}
\item U: die draad is niet ge\"initialiseerd: als je de spanning opzet weet je niet wat de waarde is van uw draden in de schakeling. Je kan daarvoor X gebruiken, maar men maakt een onderscheid omdat bij niet-ge\"initialiseerd, daar wordt alles op gezet. Binnen de kortste keren moeten die U's weg zijn. Als die toch blijven is uw schakeling slecht ontworpen.	
\item X: duidt op conflicten, dit kan op gelijk welk ogenblik ontstaan. Bv. 2 uitgangen aan elkaar hangen of tegelijk 0 als 1 opzetten. 	
\item W, L, H: hetzelfde als X, 0, 1, maar zwak aangestuurd. Sterke aansturing komt overeen met iets wat door een transistor bepaald wordt en het ander is iets wat veel zwakker is zoals bv. een weerstand die iets op 0 of 1 probeert te trekken. Als er geen transistor is die het tegengestelde probeert te doen.	
\item std\_ulogic: standard unresolved logic.
\end{itemize}

\paragraph{Slide 118:} Vectoren en matrices kan je aan elkaar toekennen als ze dezelfde dimensies heben en dezelfde grootte in iedere dimensie. De volgorde van de indices heeft geen belang hierbij (downto vs. to).

\paragraph{Slide 119:} Resolved vs. unresolved: VHDL is heel strikt. Uitgangen aan elkaar hangen (getoond op slide) mag bv. niet! VHDL wil zeker zijn dat dat niet gebeurt dus dat is niet toegelaten. Op elke regel zijn er uitzonderingen, dus zelfs CMOS mag je af en toe aan elkaar hangen: uitgangen van tristatebuffers.\\
Andere dingen zoals NMOS poorten mag je ook aan elkaar hangen zonder dat je kortsluiting krijgt. Om ook die speciale gevallen te kunnen beschrijven ga je op die draad nog een stukje tussenzetten (in gedachten): dat stukje in het blauw. Als er iets op $out_1$ en $out_2$ staat, bereken je wat er echt op die draad staat. Dat blauwe blokje gaat een AND-functie implementeren.\\
Je geeft dat aan als een resolutietype. std\_logic zal hierover nooit klagen, std\_ulogic wel.

\paragraph{Slide 120:} Gedefini\"eerd normaal voor CMOS. Als je 2 uitgangen aan elkaar hangt voor alle mogelijke combinaties, wat geeft dat? Bv. op de ene uitgang een 1 op de ene uitgang en 0 op de andere, dan krijg je een X. In die functie kan je zoveel draden aan elkaar hangen als je wilt. Hoe beschrijft men dat? De input van die functie is een vector (zonder te specifi\"eren hoe groot die vector is). Met behulp van die attributen kan je dat dus oplossen zonder exact te weten hoe groot dat is.\\
Gemakshalve begint men met een zwevende draad en daar alles aan toe te voegen, behalve voor het speciale geval er maar 1 draad is want dan moet je dat niet combineren met Z. 

\paragraph{Slide 121:} Voorbeeld van sterk en zwak: afgesloten bus. We hebben een aantal tristate buffers en een weerstand/spanningsdeler. Als die bus niet aangestuurd wordt gaat die op een bepaalde waarde staan. Hoe in VHDL: de resistor is RTL. Het is zwak in die zin dat als een van de tristate buffers actief is en een aansturing doet van de draad dat niet via H of L zal zijn maar met 0 of 1 en zal die bepalen wat er uiteindelijk op die draad komt. 

\paragraph{Slide 122:} Normaal gebruiken we bibliotheken om niet alles zelf te moeten defini\"eren.

\paragraph{Slide 123:} Verwarrend: in VHDL he je packages en libraries. Een library is geen bibliotheek, het is er maar een stukje van. Je hebt een package waar definities in staan en die worden ergens bewaard, dus een library kan uit meerdere packages bestaan. Een package zit in een folder/library. Op de slide zeggen we dat we alles gaan gebruiken, maar je kan ook gewoon onderdelen gebruiken.

\paragraph{Slide 124:} Die bibliotheken maken veel gebruik van overloading: manier om een bewerking die je hebt op nieuwe types te kunnen toepassen zonder de oorspronkelijke functies/programma te moeten herschrijven. In VHDL zit bv. ingebakken hoe je getallen optelt. Op het moment dat men een optelling tegenkomt gaat men kijken wat men wil optellen: ziet men dat het een bit\_vector is gebruikt men die versie, anders een andere versie.\\
Op die manier kan je dingen uitbreiden.

\paragraph{Slide 125:} Bitvector die een betekenis heeft van een unsigned of tweecomplement getal, als je die bibliotheek insluit, die defini\"eert hoe optellingen op bitreeksen moeten gebeuren, dan kan je in uw programma bitreeksen gaan optellen. Deze gebruik je normaal standaard omdat ze gestandaardiseerd zijn.

\chapter{Les 8}

\section{Slides: 4\_Combinatorisch}

\paragraph{Slide 126:} We hebben de aspecten van VHDL behandeld, we zijn begonnen met de syntax van de taal. We gaan nu nog kijken hoe we bewerkingen beschrijven.

\paragraph{Slide 127:} In eerste instantie gaat het over logische bewerkingen. Je moet opletten: als je naar de prioriteit kijkt bij een logische functie heeft het complement de hoogste prioriteit, dan de vermenigvuldiging en dan de optelling. Hier heeft NOT de hoogste prioriteit, maar al de rest staat op hetzelfde niveau. Als je twijfelt kan je beter haakjes gebruiken. Je kan op vectoren bewerkingen doen (logische) en die gebeuren bitsgewijs. 

\paragraph{Slide 128:} Rekenkundige bewerkingen: in VHDL kan je even gemakkelijk een berekening of exponentberekening gebruiken als basisbewerking. Het is niet omdat het niet onmiddelijk een hardwareimplementatie is dat het onmogelijk is te gebruiken in VHDL. Die bewerkingen kan je op gehele en re\"ele getallen doen (maar daar heeft modulo gaan betekenis). Als je naar de fysische datatypes kijkt is het heel beperkt: je kan seconden optellen en aftrekken maar niet vermenigvuldigen. Je kan wel een re\"eel getal vermenigvuldigen.

\paragraph{Slide 129:} Schuifoperaties: de linkse operand bestaat uit een bitvector/standard logic vector/booleans/\ldots de tweede waarde is normaal een geheel getal dat aangeeft over hoeveel plaatsen je opschuift. Wat dat doet zie je aaan de term.

\paragraph{Slide 130:} Vergelijkingen: /= geeft aan dat het verschillend is van. Je kan je nooit vergissen met de toekenning/vergelijking, je kan hetzelfde symbool ($<=$) voor 2 betekenissen gebruiken. Op gehele getallen en dergelijke is dat vanzelfsprekend. Je kan dat ook op vectoren toepassen. Als die even groot zijn, is dat oook voor de hand liggend. Het is dan alsof het getallen zijn, maar het is er van geen kanten mee gekoppeld! Let wel: je kan bitvectoren van een verschillende lengte ook vergelijken. Daarom heeft men een procedure: je begint bij de meest beduidende cijfers, als die gelijk zijn ga je kijken naar het tweede beduidende cijfer enzovoort. Je gaat bit per bit vergelijken. De twee vergelijkingen die er staan zijn gelijk: zijn bitvectoren en er wordt van links vergeleken: eerste 4 bits links zijn gelijk aan de eerste 4 bits rechts (onder). Boven: linkse is de grootste bitvector. Het is dus beter om vergelijkingen op bitvectoren met verschillende lengte te doen.

\paragraph{Slide 131:} Specifieke bewerkingen op vectoren: je kan vectoren aaneenschakelen: bundel van vectoren samenvoegen tot bv. 1 grote bundel draden.\\
De toekenning gebeurt altijd via een links en rechts element: de meest linkse index is 0, de meest rechtse is 1. Voorbeeld: bus 5 wordt verbonden met A 0.

\paragraph{Slide 132} Hoe hardware beschrijven met die syntax? 

\paragraph{Slide 133:} Hardware beschrijven gebeurt in 2 stukken: declaratie waar je het als een zwarte doos bekijkt, je kijkt naar de in- en uitgangen: wat zijn de poorten die eraan verbonden zijn? Het tweede deel is de architectuur: wat zit er in de doos? Aan die poorten geef je namen en in welke richting ze informatie doorgeven. Wat nieuw is is die generic: je kan generische constanten gebruiken, wat binnen de beschrijving van de architectuur als een constante gezien wordt maar waarvan je nog niet weet wat de waarde van die constante gaat zijn. Dat laat u toe om een beschrijving te maken voor een n-bit opteller. Als je die later gaat gebruiken kan je die n gaan specifi\"eren. Je moet geen verschillende beschrijvingen doen in VHDL voor al die verschillende soroten tellers. $\rightarrow$ 1 beschriving voor iets wat voor verschillende gevallen gebruikt kan worden.\\
1 of meerdere architecturen: een component kan verschillende implementaties of beschrijvingen hebben. Wanneer je die gaat gebruiken gaj e zeggen waarvoor je die component gaat gebruiken met welke implementatie.

\paragraph{Slide 134:} Die architectuur bestaat uit kleinere stukes hardware. Die kleinere stukjes zijn die parallelle uitdrukkingen: concurrent statements. Dat beschrijft op zichzelf een stukje hardware. Het specifieke daarvan is dat het altijd werkt wanneer de spanning opstaat en dat het allemaal tegelijkertijd werkt. Die twee poorten werken alletwee constant. Zodra er iets verandert zijn ze alletwee aan het werk. Ook de volgorde waarin je die poorten tekent maakt geen verschil. Ook in VHDL maakt die volgorde niet uit bij parallelle uitdrukkingen. Ieder van die 2 uitdrukkingen is een parallele uitdrukking en wordt tegelijkertijd uitgevoerd. Als je die 2 lijnen omwisselt (van de NANDs) heb je juist dezelfde uitdrukking.\\
Je hebt 2 manieren om parallelle uitdrukkingen te maken: structurele beschrijving (letterlijke vertaling van schema) of abstracter: gedragsbeschrijving. Je zegt dan niet hoe het moet gebouwd/ge\"implementeerd worden, gewoon zeggen wat het doet en u geen zorgen maken over hoe het ge\"implementeerd gaat worden. 

\paragraph{Slide 136:} Twee naar 1 multiplexer: 2 ingangen, een selectoringang en een uitgang. Met poorten is dat zoals getoond op de slide. De VHDL beschrijving staat ernaast. Dat is vrij uitgebreid. Je kan daar deels op besparen: eerst aangegeven wat alle interne draden zijn, dan drie keer component: 3 soorten component met bepaalde in- en uitgangen (beschrijft niet wat die doen of hoe die ge\"implementeerd zijn $\rightarrow$ zoals op het schema: je tekent een AND poort maar zegt niet hoe die ge\"implementeerd is). In een gewone schakeling die gebruik maakt van poorten weet je dat je die ter beschikking hebt. Al die componenten steek je dus in een bibliotheek. Op het moment dat je dan zelf iets maakt, laad je de bibliotheek en blijft jouw programma overzichtelijker. Er staat dat we 4 poorten hebben. Ze krijgen een naam en wat voor type het is en welke draden gebruikt worden (zo geef je aan dat er met iets anders verbonden wordt). 

\paragraph{Slide 137:} Naast de beschrijving, of dat nu met een gedrag is of structureel, heb je ook de mogelijkheid om de configuratie aan te geven: verband leggen met implementatie die je gaat gebruiken want dat moet je weten op het moment dat je begint te simuleren. Het gaat de link leggen tussen wat ter beschikking is als component en wat je in de bibliotheek hebt.\\
Als je geen AND poort hebt met 2 poorten, enkel met 3, dan kan je die gebruiken. Dat ga je alleen maar gebruiken als het echt nodig is. Als je dezelfde namen gebruikt als die in uw implementatiebibliotheek zit, kan VHDL dat raden.

\paragraph{Slide 138:} Gedragsbeschrijving is veel krachtiger en heeft iets meer mogelijkheden en is iets ingewikkelder.

\paragraph{Slide 139:} Er zijn twee basisuitdrukkingen, die komen met een stuk hardware overeen: toekenning van conditionele signalen.\\
Wat op de uitgang f komt is d1 als s = 1 of H (dat is hetzelfde). Anders d0 als aan die voorwaarden voldaan is en in alle andere gevlalen een X. $\rightarrow$ Beschrijving. Je ziet een ingebouwde prioriteit: je doet eerst de eerste test en als die waar is stop je daar, als die niet waar is ga je naar de volgende test. Het kan ook zijn dat die testen op zich neveneffecten hebben en dan kunnen uw testen impact hebben op wat je moet doen. Dat is anders bij toekenning van geselecteerde signalen. Daar ga je op een andere manier werken: afhankelijk van het signaal beschrijf je voor ieder van de mogelijkheden wat het signaal zal zijn. Je gaat dus niet testen.\\
Alle mogelijkheden moeten beschreven zijn en s moet gekend zijn, af te leiden zijn, wanneer het ge\"implementeerd wordt. Hier is het wel een verschil: geen prioriteit: als je d1 en d0 omwisselt gaat dat hetzelfde werken.\\
Die s gaat us ook geen neveneffecten hebben want ze wordt maar 1 keer ge\"implementeerd.

\paragraph{Slide 140:} Voorbeeld van VHDL beschrijving: n-bit opteller (n is in het groen aangeduid). Er staat een defaultwaarde bij. Als je niet anageeeft wat die n is, dan zal die gelijk zijn aan 4. Bij de beschrijving kan je dan uw n gebruiken, wat die ook moge zijn.\\
Hier is het met standard\_logic dus er moet een bibliotheek gebruikt worden. Welke gaan we gebruiken? Hangt er vanaf wat we ermee willen doen: 2 std\_logic optellen met elkaar en dan moet je de juiste bibliotheek inladen. Het is van belang de juiste bibliotheken te gebruiken om te begrijpen wat het juist doet.\\
Onderaan de beschrijving: intern een bundel draden die je gaat gebruiken, die worden gedeclareerd. Tusen begin en end: parallelle uitdrukkingen, komt overeen met de vergelijkingen in \textbf{Slide 139}, maar ze zijn parallel: je mag ze door elkaar halen. Hoe doe je die berekening? Dit is een gedragsbeschrijving, je zegt dus niet hoe de optelling moet ge\"implementeerd worden, je zegt gewoon dat die moet gebeuren. Eerst worden de getallen uitgebreid met een extra getal aan de linkerkant. XOR tussen carry die binnenkomt en naar buitengaat. In de onderste lijn ga je die opnieuw berekenen, die resulteeert in de carry die naar de meest beduidende bit gaat en zo de overflow berekenen.

\paragraph{Slide 141:} Naast die twee parallele uitdrukkingen is er nog een derde parallele uitdrukking: proces. Een parallelle uitdrukking dient om een stuk hardware te beschrijven. Proces: een gewoon ordinair programma dat beschrijft wat die hardware precies doet, het beschrijft het gedrag ervan. Het beschrijft niet stap voor stap wat het doet, gewoon het eindresultaat. Dat is het makkelijkste om dat via een traditionele taal te beschrijven. Je gaat dus geen parallelle uitdrukkingen gebruiken, maar sequenti\"ele. Dit is een traditioneel programma.\\
Parameters: signalen die impact hebben op de hardware. Wat gebeurt er: wanneer gaat er op de uitgang iets wijzigen bij een combinatorische schakeling? Als er aan de ingang iets wijzigt. Zodra een van de signalen aan de ingang verandert wordt het proces opgestart en berekend wat er op de uitgang gaat komen en beschikbaar gesteld. Vandaar dat je ook een aantal bijkomende traditionele uitdrukkingen hebt: if, case, lussen,\ldots Je kan hier variabelen en signalen gebruiken (normaal alleen signalen bij parallelle).

\paragraph{Slide 142:} In een programma kan je de gewone trukjes toepassen en variabelen gebruiken. Een van de plaatsen waar vaak verwarring onstaat is het verschil begrijpen tussen variabelen en signalen omdat die verschillende impacten hebben.\\
Signalen worden normaal gebruikt voor fysische dingen: komt normaal overeen met een draad waarop je een golfvorm kan meten. Vermits een parallelle uitrdukking stukjes hardware weergeeeft die met draden verbonden zijn is het logsich dat je alleen signalen kan gebruiken op niveau van de parallelle uitdrukkingen. Daar ga je dus nooit variabelen gebruiken, uitsluitend in een subprogramma of procedure. Als je wat in een variabele zit naar buiten wil brengen moet je dat toekennen aan een signaal voor je dat buiten het proces krijgt.\\
Toekenning aan variabele en signaal: stel dat de stukjes code uit een proces komen (zowel variabelen als signalen kunnen dus gebruikt worden). Wat binnen die test staat zal altijd waar zijn bij variabelen maar niet bij signalen. Rechts: s wordt 1 (links: v = 1), maar het signaal is niet van waarde veranderd, je zegt gewoon dat dat gaat gebeuren, op het einde van het proces.\\
s $<=$ 1 $\rightarrow$ s woodt 1 op het einde van het proces. s $<=$ 0 $\rightarrow$ s wordt 0 in plaats van 1.\\
Dan gaan we s testen, maar deze heeft nog geen nieuwe waarde gekregen, je kan daar niet voor voorspellen of dat waar gaat zin of niet.\\
Welke s wordt er getest: de waarde die het had op het begin van het proces, toen het opgestart werd. Hieraan kan je niet zeggen of die 0 was of 1. Het kan zijn dat het soms uitgevoerd wordt en soms niet.

\paragraph{Slide 143:} zorg dat je dit begrijpt bij het examen. Er is een proces dat iets doet: het stelt een variabele op 0, dan x doorlopen: is een vector van 3 elementen. Als er een 1 is op die plaats in de x, tel je een 1 op bij de term. Op het einde moet je dat toekennen aan het signaal zodanig dat het extern zichtbaar is.\\
Wat gaat dat proces doen: gaat het aantal enen in x bepalen. De hardware hoeft dat niet iteratief te doen, maar we verwachten dat dit in simulatietijd ogenblikkelijk uitgevoerd is. Dat is geen berekening zoals het daar beschreve staat, het is een programma zodat we kunnen neerschrijven wat de werking is.\\
Hoe kan je dit implementeren: met twee full adders (adder die eerste 2 bits optelt en dan een die de derde erbij optelt. Einde: komt overeeen met count).\\
Variabelen vervangen door signaal: tussenresultaten stockeren. Dan krijg je het rechtse. Je zou veronderstellen dat dat hetzelfde doet, maar dat is niet zo. Wat komt er op cnt te staan als x verandert? Als er geen enen inzitten komt er een 0 op te staan en anders komt er een oude waarde +1 op te staan. Waarom: in de eerste stap wordt count 0 (op het einde van het proces), dan gaan we in de lus en als er geen enkele 1 voorkomt gaat er geen nieuwe toekenning zijn en gaat cnt = 0 op het einde van het proces. Als er wel een 1 instaat, wordt bij cnt 1 opgeteld. Maar bij welke waarde van cnt? $\rightarrow$ De waarde van cnt toen het proces werd opgestart. Elke keer je een 1 ziet, ga je zeggen dat in cnt de oude waarde van cnt + 1 moet komen te staan. $\rightarrow$ met die signalen werken is niet zo vanzelfsprekend omdat het totaal verschillend is van wat we gewoon zijn. Met signalen is dat anders, daar moet je constant in gedachten houen dat het later zijn waarde pas gaat krijgen, maar je berekent nu pas wat het gaat worden. Ander voorbeeld: wat onderaan staat mag je enkel schrijven met variabelen, nooit met signalen: kortsluitng tussen uitgang en andere uitgang, maar vergeet dat even. Wat is het probleem: je krijgt een waarde van cnt, telt daar 1 bij op, dan weer,\ldots $\rightarrow$ aan hypersnelheid die cnt laten oplopen met altijd 1 meer. Zal aan de snelheid zijn van de vertraging om er een bij op te tellen. Je kan dat ook zien aan de VHDL code: stel nieuwe waarde van cnt. Dan zeg je dat cnt die waarde + 1 gaat zijn. Aan het einde van het proces krijgt cnt ook die waarde, dan kijkt het proces of het veranderd is en dat zal zo zijn en zal dat proces weer opstarten. 

\paragraph{Slide 144:} Dat proces is een derde manier om parallelle uitdrukkingen te hebben. Voor VHDL bestaat er eigenlijk maar 1 soort parallele uitdrukking: proces. Die andere twee zijn vereenvoudigde notaties om het de mens makkelijker te maken. Je kan de voorbeelden op de slide als een proces schrijven (zoals links). Eigenlijk is de basisparallelle uitdrukking het proces, alles kan daarmee beschreven worden. Het proces komt overeen met een stukje hardware. Waarom die kortere uitdrukkingen: makkelijker voor ons te lezen en schrijven. 

\paragraph{Slide 145:} Bij sequenti\"ele uitdrukkingen heb je naast de if en case ook lussen. Dat is iets wat nooit stopt (in tegenstelling tot gewone programmeertaal), het is dus niet abnormaal om oneindige lussen te hebben, maar je gaat het niet altijd nodig hebben. Soms ga je iets een aantal keer willen doen of zo lang het nodig is. Onderaan: index voor for-loop moet je niet declareren, gebeurt automatisch in die lus.

\paragraph{Slide 146:} Niet met een aantal paralllelle uitdrukkingen zoals daarnet, maar met 1 proces: een proces dat onmiddelijk de ganse component beschrijft. Ook hier moet je telkens in gedachten houden: op het einde van het proces. Wanneer opgestart: w en `en' (enable), als die veranderen wordt het proces opgestart. 2 gevallen: en = 1 of en = 0. In alle andere gevallen weet je niet goed wat er moet uitkomen. Als enable = 0 zowel in sterke als zwakke waarden, moeten de uitgangen nul zijn. Als enable 1 is, hangt het af van w. Je moet ook rekening houden met het feit dat het ook X, Y, don't care en Z kan zijn.\\
Je zou alle mogelijke combinaties kunnen testen en opschrijven wat het moet zijn, maar of uw ingang nu op een sterke of zwakke 1 of 0 staat, maakt niet uit. Of die ingang nu niet ge\"initialiseerd is, je weet niet wat op de uitgang komt.\\
Je werkt met de bibliotheek, de rechtse functie staat ook in de bibliotheek: wat de waarde ook is, je zet het naar een van de 3 om. Dan hoef je ook niet op alle mogelijkheden te testen, gewoon op 0 en 1 en alle andere gevallen worden in die laatste gevallen opgevangen.\\
Null: zegt dat er niks gebeurt: no-operation want VHDL kan er niet tegen dat je geen uitdrukking zet, je moet altijd een uitdrukking hebben. Stel dat er op die w op een van de 2 bits een X staat, dan kom je in others, dan ga je niks doen, er komt dan op Y XXX te staan.

\paragraph{Slide 147:} Lussen om componenten te genereren. Je hebt bv. een optelling: 1 basiscomponent, een full adder en die gebruik je n keer bv.\\
Als je een schema hebt moet je die n keer tekenen, bij VHDL niet: je zegt dat je die er n keer wil inzetten.

\paragraph{Slide 148:} In plaats van n keer te moeten opschrijven schrijf je dat op die manier, da's veel compacter en beter verstaanbaar en het heeft hetzelfde effect. De compiler gaat dat dan controllen: die parallelle uitdrukkingen n keer na elkaar herhalen. Soms wil je dat conditioneel: bij opteller: minst beduidende bit moet lichtjes anders behanded worden dan de resterende bits. Je moet dat dus ook kunnen aangeven. Dat gebeurt met de tweede uitdrukking op de slide: iets uitvoeren mits aan de voorwaarde voldaan is.\\
Je kan binnen een generate een andere generate zetten (ook conditioneel), je kan die nesten.

\paragraph{Slide 149:} Illustratie: vermenigvuldiger: m*n vermenigvuldiger. Let wel: welke bibliotheek wordt gebruikt: unsigned $\rightarrow$ op natuurlijke getallen, niet op gehele getallen.\\
De ene gingang heeft m bits, de andere n en het resultaat heeft n+m bits. 

\paragraph{Slide 150:} Als je weet hoe het gemaakt moet worden krijg je dit. Dit is hetzelfde als de schema's over de vermenigvuldiger. Je hebt maar 1 component nodig: AND-poort, maar ook opteller, maar dat moet je niet als component zien: VHDL weet wat de betekenis van een optelling is, dat zit in de beschrijving, is een onderdeel van de taal die VHDL verstaat.\\
Je hebt de verbindingen (type). Er zijn 2 soorten: PCvect: vector van parti\"ele producten, van tweedimensionale producten. Anderzijds heb je een vector van parti\"ele sommen.\\
Signal: Alle draden die in de vermenigvuldiger nodig zijn.\\
Er is 1 parallelle uitdrukking is die een for-generate is. Binnen die uitdrukking kan je andere parallelle uitdrukkingen gebruiken, in dit geval 4. Die worden alle 4 tegelijkertijd uitgevoerd. Die worden 4*m keer parallel uitgevoerd als dat ontrold is.\\
Die eerste gaat een parti\"eel product maken met behulp van de AND-poorten.\\
De 3 anderen: if-generates: 3 speciale gevallen: helemaal in het begin, als je nog niks hebt om bij op te tellen, daarna heb je altijd 2 dingen die je met elkaar gaat optellen (resultaat parti\"ele som van de vorige + parti\"eel product erbij tellen) en bij die laatste doe je dat ook, maar bij de eerste twee heb je de minst beduidende bit niet meer nodig en die breng je naar buiten. Bij de laatstse heb je alle bits nodig, vandaar dat je 3 gevallen hebt. Die 3 testen op verschillende zaken zodanig dat altijd maar 1 van de 3 voor een bepaalde waarde van i waar is.  Er zal er altijd maar 1 zijn die iets genereert.

\section{Slides: 5\_Sequentieel} 

\paragraph{Slide 1:} Een schakeling waarbij de uitgang alleen afhangt van de ingang, daar heb je niet zoveel aan. We gaan nu sequenti\"ele schakelingen bekijken: een schakeling die rekening houdt met wat er gebeurd is, die de voorgeschiedenis in rekening brengt.

\paragraph{Slide 2:} Je hebt een geheugen nodig om de voorgeschiedenis in te onthouden. Niet alles van die voorgeschiedenis, we zijn alleen ge\"interesseerd in iets bijhouden dat equivalent is met wat er allemaal tevoren al gebeurd is en dat zijn die toestanden. In het geheugen gaan we toestanden onthouden: FSM. Wat zit er naast het geheugen nog in? We moeten de toestand aanpassen want er is iets nieuws gebeurd zijn en we moeten ervoor zorgen dat de juiste informatie op de uitgang gebracht kan worden en dat kan op de manier zoals voorgesteld.\\
Je hebt een combinatorische schakeling die 2 taken heeft:
\begin{enumerate}
\item Bepalen wat de nieuwe toestand zal zijn waar we naartoe gaan, die rekening houdt met de huidige toestand en de ingangen die er nu zijn.	
\item Ervoor zorgen dat gebruik makende van de huidige toestanden en de ingangen die je hebt wat erop moet komen te staan.
\end{enumerate}	
Er zijn 2 technieken om het geheugen te implementeren.
\begin{enumerate}
\item Component: capaciteit bv. waarop je lading brengt, die blijft daarop staan en heeft een geheugenfucntie. Dat wordt ook gebruikt in heel veel geheugens, maar je kan niet de ideale condensator maken. Als je er lading op brengt en je wacht lang genoeg, dan die is die lading weg. Als het over kleine capaciteiten/capacitoren gaat spreekt men over 1 milliseconde. Hoe kleiner de capaciteit is, hoe sneller die lading weg is.\\
Als die info niet langer moet bewaard blijven kan je dat wel gebruiken, als je maar rap genoeg werkt, geeft het niet dat die info verdwijnt. $\Rightarrow$ Dynamische logica $\rightarrow$ er is een maximale en minimale snelheid waaraan het moet werken: snel genoeg werken of het gedraagt zich niet meer als een gehuegen.	
\item Terugkoppelsysteem: de uitgang terugvoeren naar de ingang en je brengt de component in een bepaalde toestand en door het feit dat die uitgang teruggekoppeld is naar de ingang houdt die zichzelf in leven. Het moet wel een terugkoppeling zijn zodanig dat het niet omkeert van waarde tijdens het pad dat het volgt. $\rightarrow$ Wij gaan dit gebruiken: zolang de spanning opstaat blijft het er voor altijd opstaan.
\end{enumerate}

\paragraph{Slide 3:} De uitgang is enkel en alleen een functie van de toestand. Mealy: de uitgang is in functie van de toestand en van de ingangen die er op dat moment zijn. Hier is er een combinatorisch verband tussen de uitgangen de ingangen.

\paragraph{Slide 4:} Voor de sequenti\"ele schakeling heb je 2 manieren, tot nu toe hadden we het over de asynchrone schakeling: er verandert iets en daardoor komen we in een nieuwe toestand. Niet zo handig om te ontwerpen: storingen etc. gaan effecten hebben. Nadeel: als een overgangsverschijnsel u in een andere teostand brengt, dan geraak je daar nooit meer vanaf, je bent vanaf dan verkeerd bezig. Daar moeten we dus erg mee opletten, bij combinatorisch is dat niet zo'n probleem: ook aan de uitgang even een overgangsverschijnsel maar daarna weg.\\
Het is dus niet zo interessant om asysncrhone sequenti\"ele schakelingen te maken, wel sequenti\"ele: we bekijken ingangen maar op 1 bepaald ogenblik: als we min of meer zeker zijn dat alle overgangsverschijnselen weg zijn. Het gebeurt op basis van het kloksignaal en dan verandert het op een gecontroleerd moment. Het ontwerp wordt dan veel makkelijker.\\
De meeste schakelingen zijn synchrone schakelingen.\\
Stijgende/dalende flank: verandering van 0 naar 1 (stijgend) of 1 naar 0 (dalend).

\paragraph{Slide 5:} Hoe wordt geheugen gemaakt? Wat zijn de tijdsgedragparameters? 

\paragraph{Slide 6:} Basiscomponent: geheugenelement voor 1 enkele bit. Hoe kunnen we dat maken? Eenvoudigste: eenvoudige schakeling en zorgen dat er positieve terugkoppeling is. Wat is terugkoppeling: als je naar ene uitgang kijkt, die wordt teruggevoerd naar de ingang en we komen terug op de plaats waar we vertrokken zijn. Positieve terugkoppeling want op het pad dat we volgen wordt het signaaal niet ge\"inverteerd (anders zou het beginnen oscilleren).

\paragraph{Slide 7:} Timingdiagram: altijd 2 uitgangen: Q en $Q_n$. Voor het ontwerp zou het het interessantst zijn dat we zowel het signaal als zijn complement beschikbaar hebben: converter uitsparen in het ontwerp. Een uitgang is dus altijd het complement van de eerste uitgang. We hebben 2 signalen: set en reset. Het is geen waarheidstabel wat getoond is! Als s en q op 0 staan wordt de waarde bewaard: huidige uitgang is dezelfde als vorige uitgang $\rightarrow$ wordt op dat moment als geheugen gebruikt. Met de set zorg je dat er een 0 in het geheugen komt, met de reset zorg je dat er een 0 komt in het geheugen.\\
Als s en r 0 zijn zal q ook 0 zijn (veronderstellen we) en $Q_n$ = 1. Als we s op 1 brengen komt $Q_n$ op 0 en komt de Q op 1 (want 2 nullen aan de $Q_n$ ingang) $\rightarrow$ stabiele terugkoppeling: er verandert niks meer. Neem je de set weg, gebeurt er niks want de terugkoppeling zorgt ervoor dat het in die toestand bewaard blijft. Als de reset op 1 komt dan gaat de Q op 0 komen met als gevolg dat de $Q_n$ op 1 komt en dan zitten we weer in een stabiele terugkoppeling. Als we de reset wegnemen blijft de stabiele teostand bewaard. Breng je de set en reset aan, dan kan er op de uitgangen niks anders dan een 0 staan, dan klopt het niet meer dat het een het complement is van het andere. Het is dus geen goed idee om dat te gebruiken: doe dat niet (NA). Als we 1 van de 2 signalen wegnemen zal hetgeen wat het langst blijft aanliggen overblijven. Niet de ene na de andere wegnemen maar tegelijkertijd: dan staan er allemaal nullen op de ingangen met als gevolg dat de 2 uitgangen 1 worden, dan zullen ze 0 worden, dan terug 1,\ldots $\rightarrow$ het zal beginnen oscilleren. De frequentie waaraan het oscilleert hangt af van de vertraging van de poorten. Je krijgt een racecoditie: wie is het sterkste/snelste: de snelste zal ervoor zorgen dat hij uiteindelijk wint. Het minste verschil dat er tussen die twee poorten is zal dat niet blijven oscilleren: een van de twee pulsen zal smaller worden en de andere breder. Uiteindelijk ga je dan naar een 1 of een 0, alleen weet je niet wanneer dat gaat gebeuren, je weet niet waar je terechtkomt, dat hangt af van toevalligheden. Het is dus totaal onbruikbaar om een ontwerp mee te maken. Voor een ontwerp moet je regels hebben: als ik dat doe zal dat gebeuren. Die roze piekjes zijn dus een ongedefini\"eerde toestand.

\paragraph{Slide 8:} Ook met NAND-poorten: wordt hier meer mee gebruikt. Ook hier heb je een set en een reset, maar hier hebben de set en reset een actief lage betekenis: gaan alleen maar effect hebben als ze laag zijn, bij NOR was er enkel effect als ze hoog waren. 

\paragraph{Slide 9:} Het grote probleem van die latch die we tot hiertoe hadden is dat het een asynchroon sequenti\"ele schakeling is. Overangsverschijnselen heben invloed op de uitgang en kunnen het in een ongewenste toestand brengen.\\
We willen die klok dus kunnen controleren: wanneer mogen set en reset bekeken worden. $\rightarrow$ Geklokte latch gebruiken. Alleen als het kloksignaal 1 is worden de set en reset doorgegeven naar de latch. Wanneer de klok 0 is mogen er overgangsverschijnselen zijn, die hebben geen enkel effect.

\paragraph{Slide 10:} In veel gevallen wil je niet zozeer dat er een 1 inkomt met 1 signaal en een 0 met een ander signaal, je wil informatie kunen bewaren. Dat noemt men een data latch: om 1 bit aan data te bewaren.\\
Als de data 1 is ga je die setten (latch op 1 brengen), als die data 0 is ga je de latch op 0 brengen. Dat kan je op de manier getoond: data en ge\"inverteerde gebruiken om te setten of resetten.\\
Op die manier kunnen we gedurende 1 klokperiode 1 bit aan data onthouden.\\
Tijdsgedrag: wat zijn de tijdsgedragparameters bij een combinatorische schakeling: vertragingstijd: er verandert iets aan de ingang, hoe lang duurt het eer je dat ziet aan de uitgang?\\
Verschillende vertragingen uitgerekend. Ofwel van de data-ingang naar een van de uitgangen (als de klok 1 is!). Als de klok verandert (1 wordt) afhankelijk van wat de ingangen op dat moment waren en we veronderstellen dat die niet gelijktijdig veranderen want dan gaat het eerst het ene en dan het andere zijn. Om nul te maken moet je de reset activeren: door inverter dan door de twee NANDS, door de rechtsboven NAND en dan ben je er. Er hangt niet 1 tijd aan, er zijn redelijk wat verschillende tijden. We gaan nooit gevraagd worden om de vertragingstijd te berekenen.\\
Er zit redelijk wat speling op. Wat is nu de vertraging van die latch. Vaststelling: we willen die latch gebruiken om informatie te bewaren. Het is niet de bedoeling dat als de klok 1 is de data verandert en je dat kan mee volgen, dat is geen geheugenelelement. De bovenste vertragingstijden (van pijl 1) doen niet ter zake want zo gaan we de klok niet gebruiken. \textcolor{red}{Op het examen: als er gevraagd wordt wat de vertraging is voor een geheugenelement, zeg dan nooit van de dataingang naar de uitgang, dat is totaal irrelevant.} De enige zinvolle vertraging die je hebt is van de klok naar de uitgang. Dat is de enige vertraging die telt. 

\paragraph{Slide 11:} Vertraging is niet de belangrijkste parameter, wel de setup- en de holdtijd.\\
Setup: op het moment dat de klok verandert, op het moment dat die begint te onthouden (actieve klokflank), vanaf dan kan de uitgang niet meer veranderen: vanaf dan begint hij te onthouden. Rond die actieve klokflank mag je de data niet veranderen want dan kan je probelmen krijgen. Een tijdje voor de actieve klokflank moeten die stabiel zijn en een tijdje erna ook. Je moet daarmee rekening houden in uw ontwerp.\\
Voorbeeld: als D tijdig genoeg verandert (stabiel is wanneer de klok verandert) dan werkt dat zoals het moet. Als je die data kort voor de klok laat veranderen werkt dat niet meer, dan is de toestand ongedefini\"eerd. Dit werkt maar als we veronderstellen dat wat op die bovenste NAND-poort staat het omgekeerde is van de onderste NAND-poort.  Binenin het geheugenelement kan je inconsistentie krijgen.\\
Door te specifi\"eren dat de setup tijd de tijd van 1 inverter is dat die minstens die tijd ervoor stabiel moet zijn kan je garanderen dat dat probleem niet optreedt.

\paragraph{Slide 12:} Ze zijn ook belangrijk voor metastabiliteit: inverter en de transferkarakteristiek daarvan. De latch kan je vereenvoudigd tekenen zoals de groene. De twee assen zijn verwisseld ten opzichte van elkaar bij het blauwe. Wat zijn de stabiele punten, waar gaat het geheugenelement zich in blijven bevinden? Op het snijpunt van die 2 curven. Groen: er is 1 of 0 in opgeslagen.\\
Rode punt: strict gezien is dat ook een stabiel punt en je kan daar eindeloos in blijven zitten, maar het is een metastabiel punt: het is stabiel maar het gaat daar in normale omstandigheden niet lang in blijven zitten: de minste verstoring/ruis gaat ervoor zorgen dat dat redelijk snel daaruit verdwijnt. Kijken we naar het mechanische equivalent: heuvel met 2 dalen. De stabiele punten zijn dat de bal beneden ligt. Als je heel vorozichtig bent kan je ook op de top een bal leggen en blijft die liggen. Maar de minste trilling/wind is gaat die beginnen bewegen en naar beneden rollen.\\
Is het zo erg dat je daarin zit? $\rightarrow$ Ja! Dat ligt rond de helft van de voedingsspanning: noch een 0, noch een 1: je moet erdoor maar je moet zorgen dat je er zo snel mogelijk doorbent want het genereert spanningen waar de rest van de schakeling niet mee overweg kan en je weet niet hoe die gaat reageren.\\
Hoe kan je in dat metastabiel punt terechtkomen en daarin blijven? Je zorgt voor energie voor alle dingen die tegenwringen (capaciteiten): genoeg energie om die opgeladen te krijgen naar iets anders. Je moet doseren hoe hard je ertegen schopt: die komt daar en is juist op dat moment al zijn energie kwijt en heeft net dat beetje extra om verder te rollen niet meer. Hetzelfde gebeurt elekrtisch. Als je niet genoeg energie levert om van de ene kant naar de andere te gaan kom je dus in dat punt.\\
Redenen: als je in een geklokt systeem werkt: hoeveel tijd geef je je om te veranderen, als die klok te smal is heb je niet genoeg tijd noch energie om aan de andere kant te geraken. Daarom heb je specificaties wat de minimumbreedte van de klok is.\\
Wat gebeurt er als je je er niet aan houdt: iets inconsistent binnenin: de ene wil naar de ene kant en de andere naar de andere kant en dan heb je te weinig netto-energie.\\
Ook daar kunnen we rekening mee houen en daar moeten we rekening mee houden bij ons ontwerp om zeker te zijn dat er zeker geen schending is van die tijden: gedurende die tijden mag de data niet veranderen.\\
Als we er niet lang inzitten heeft het niet veel effect als je eruit bent voor de volgende klok komt (je de informatie gebruikt). Als het langer duurt is het wel een probleem. Kunnen we bepalen hoe lang het duurt om uit die metastabiele toestand te geraken? $\rightarrow$ Nee. Hangt ook af van de ruis in de schakeling. Als er veel ruis is in de schakeling, ga je er snel uitgeraken, ook de helling vna de curve zal hierin meespelen. Je kan geluk hebben en er binnen een microseconde uitgeraken of pech hebben en er pas na 3 uur uitgeraken (al is die kans klein), je hebt nooit de garantie.\\
De tijd dat je metastabiel bent neemt exponenti\"eel af maar wordt niet 0 (denk ik).

\chapter{Les 9}

\section{Slides: 5\_Sequentieel} 

\paragraph{Slide 13:} Basiselement voor sequentiele schakelingen: geheugenelement. Vorige les hadden we het over de geklokte latch. Dat had zn voordelen: bepalen wnr we naar een nieuwe toestand overgaan, hoe we onthouden wat er in een vorige toestand gebeurde. Nadeel: zolang de klok 1 wekrt dat transparant: veranderingen op de ngang worden ook zichtbaar op de uitgang. Dat is niet de bedoeling. Dankzij de klok willen we tegemoet komen aan het feit dat er altijd overgangsverschijnselen meespelen. Als we ingangen zo weinig mogelijk effect willen laten hebben op de uitgang kunnen we de tijd dat de klok 1 is zo klein mogelijk maken, maar door metastabiliteit mag je dit niet te klein maken.

\paragraph{Slide 14:}  Het feit dat die transparant is kan voor problemen zorgen: je verwacht dat X opgeslagen wordt in de D-latch en op de volgende klok opgeslagen wordt in de tweede (1 klokperiode vertraging). Als die klok transparant is en de ingang rimpelt door naar de uitgang, dan is dat niet het geval, zoals te zien is op het diagram. De veranderingen op Q1 gaan onmiddelijk gevolgd worden en binnen dezelfde klokperiode krijgen alle geheugenelementen een andere waarde. De enige oplossing hieraan is de klok kleiner maken maar dat willen we niet. Wat op de tekening staat willen we niet, daarom worden latches gewoonlijk niet gebruikt.Wat we eigenlijk willen is een element die op een flank werkt: op 1 ogenblik kijken wat de ingangswaarde is: op 1 bepaald moment. Bv wanneer we een stijgende flank hebben. De vraag is hoe je zoiets kan maken.

\paragraph{Slide 15:} Master-slave principe is makkelijkste mnier om dat te maken: elk geheugenelement opdelen in 2 delen (2 latches). Het specifieke is dat die elk op een eigen klok wekren: als de ene transparant is, is de andere dat niet en omgekeerd. Er is dus nooi een transparant pad naar de uitgang. Wanneer zien we dan veranderingen naar de uitgang? Links gaat transparant zijn als de klok laagi s, rechts als de klok hoog is (binnen 1 segment).Op het moment dat Clk2 1 wordt en de linkse dus niet meer transparant is dat de informatie zal kunnen doorgegeven worden naar de uitgang. Op dat moment kan de ingang dat niet meer beinvloeden omdat de master niet meer transparant is.De info op de ingang op de stijgende klokflank wordt opgenomen. Het hangt dus niet meer van de klokperiode af om te weten wat er precies gebeurt. Als je er zo 2 na elkaar hebt, is er 1 klokperiode verschil wanneer de info op de volgende verschijnt. In de praktijk is het meestal niet implementatie die gebruikt wordt, maar een edge-triggered flipflop.

\paragraph{Slide 16:} Niet echt een correcte naam want de vorige was ook flankgevoelig. Deze is cmopacter maar ook moielijker te begrijpen. 3 latches. De meest rechtse is een "normale" : set en reset ingang. De eerste twee gedragen zich somsals een lathc en soms niet. Als de klok 0 is gaan zowel de set als de reset op 1 staan, dan gedraagt zich dat niet als een latch want de info van D wordt geinverteerd doorgegeven alsook de info van B. Wanneer de kok 0 is, zal wat op B staan het inverse zijn van D en wat op A staat hetzelfde zijn als D.Dat gedraagt zich op dat moment gewoon als 2 invertoren na elkaar.Wanneer de klok 1 wordt gaat het zich plots wel als een latch gedragen: zal onthouden wat op A stond en wat op B stond. Vanaf dat moment zal het dat onthouden. Als de klok terug 0 wordt gaan de set en reset op 1 komen. Als dat gebeurt, zal de outputlatch onthouen wat er was. Blauwe draad: zal zorgen dat de set en reset niet tegelijk actief kunnen zijn. Een keer de lnkse 2 als latch beginnen te werken, zal de bovenste als set werken en de onderste als reset.Je kan dat ook allemaal op timingsdiagramma gaan zetten. Zo'n diagram zal niet gevraagd worden, is ter illustratie.

\paragraph{Slide 17:} In de praktijk wordt er gewoonlijk een asynchrone clear voorzien en een asynchrone preset. $\rightarrow$ bij het opstarten van het systeem wil je niet op kokken wachten maar in een gekende begintoestand zetten: alle geheugenelementen op 0 gewoonlijk. Om dat te doen, daarvoor te zorgen, wordt er een asynchrone clear/reset gebruikt. Traditiioneel is dat een actief laag signaal. In sommige omstandigheden is het ook handig om een preset te hebben omd at niet in de 0 teostand te brengen maar ind e 1-toestand.Onthoud hiervan dat het niet alleen de outputlatch is die asyncrhoon moet werken, maar ook de twee eersten. $\rightarrow$ wanneer we over de kostprijs van een flipflop spreken gaan we het hierover hebbenJe hoeft geen asynchrone clear of reset te gebruiken. Je kan het ook syncrhoon implementeren, dan gebeurt dat zoals getoond op de slide na animatie. Dat is een component die we kennen met extra poorten.

\paragraph{Slide 18:} wanneer we gaan ontwerpen, eigenlijk hebben we nu al 2 soorten latches en flipflops gezien. Strikt gezien gebruikt men een latch wanneer men niveau-gevoelig werkt (element transparant wnr signaal 1 is). Flipflop wordt vaak gebruikt bij flanken. Flipflop wordt wel als verzamelnaam voor beiden gebruikt.

\paragraph{Slide 19:} Set-reset: linksboven: flipflops, die werken op een flank. Je herkent die aan de driehoek bij de klok. Bij de niveautriggering (latches) ontbreekt de driehoek. Het bolletje, als dat ontbreekt, is het de normale actief hoge betekent. Dat bolletje betekentniet dat er een inverter voorstaat. Waarheidstabel van flipflop/latch: karakteristieke tabel: waarde aan ingang aanlegegn, hoe gaat de uitgang daarop reageren. Dit is niet wat we nodig hebben een keer we beginnen te ontwerpen. We gaan van een toestandsdiagram/-tabel vertreken waarin staat hoe je van de ene toestand naar de andere gaat.Wat u interseert is hoe je die ingangen moet aansturen om die uitgnag bepaalde veranderingen te laten doen. Je weet welke veranderingen aan deuitgang nodig zijn en wilt weten hoe je de ingang moet aanpassen darvoor. Ddat noemt men de excitatietabel. Je kan deze afleiden uit de karakteristieke tabel. Dit is wat je bij wijze van spreken vanbuiten moet kennen. Waarom staat er don't care? Hoe meer don't cares op de uitgang, hoe compacter en sneller het combinatorisch netwerk wordt gewoonlijk. Probleem: combinatie 1 1 van vanboven mag niet gebruikt worden. Het zou handig zijn als we iets nuttig konden doen met die 4e lijn.

\paragraph{Slide 20:} 4e lijn gebruikt. We kunnen de flipflop setten, resetten, onthouden en nu ook (??).Las je nu kijkt naar de excitatietabel staan er nu nog meer don't cares. De flipflop op zichzelf is iets duurder, maar er zijn meer don't cares.

\paragraph{Slide 21:} Data flipflop: gedurende 1 klokperiode gaat die info onthouden die op zijn ingang zit. Eenvoudige karakteristieke tabel en excitatietabel. Als je weet wat er volgende keer moet opkomen, leg je dat nu aan zijn ingang aan. 

\paragraph{Slide 22:} Toggle-flipflop. Als d eingang 1 is zal die van toestand veranderen. Je kan die niet in een toestand brengen, je kan die toestand alleen veranderen.Dit is typisch wat je nodig hebt in een teller. Tekening vanonder: manier om over te gaan.

\paragraph{Slide 23:} Alle basiselementen zijn gekend nu. We gaan kijken of we bouwblokken kunnen maken om op hoger niveau te gebruiken.

\paragraph{Slide 24:} Je moet onder controle hebben of nieuwe data ingeladen wordt of de vorige data onthouden wordt (onthouden: telkens opnieuw inladen) via een extra ingang.Op die manier heb je een element ter beschikking waarin je een gans woord kan onthouden en je zelf in controle hebt wnr nieuwe info onthouden wordt en wnr nieuvea info igneladen wordt.

\paragraph{Slide 25:} Variante daarop:schuifregister (!= combinatorisch element dat over 1/meer plaatsen opschuift). Hier wordt de data van een register over 1 plaats opgeschoven. Het principe is ongeveer hetzelfde als het vorige: data bewaren (niet opschuiven), ofwel wel opschuiven en dan wordt de uitgang van de ene gebruikt als ingang van de volgende. Je hebt een extra ingang nodig m te bepalen wat de data is die in de meest linkse flipflop komt. Gewoonlijk wordt het gecombineerd dat je het niet alleen kan schuiven maar ook data kan inladen. Zie animatie.Wat in het blauw staat is in uw bibliotheek als 1 enkel component beschikbaar. Als je dit soort componenten hebt, heb j een laadbaar schuifregister. Een typische toepassing: van serieel naar parallel en omgekeerd. serUit: uitgang waar de bits een voor een gaan uitkomen. Je kan dat ook omgekeerd gebruiken.Het kan ook gebruikt owrden om op een iteratieve manier een vermenigvuldiging of deling te iplementeren. 

\paragraph{Slide 26:} Andere basiscomponenten: tellers: bijhouden hoeveel keer iets al gebeurd is of moet gebeuren.

\paragraph{Slide 27:} Teller = register + opteller (waar +1 of -1 wordt bij opgeteld).Het meest efficiente is een asynchrone teller (niet omdat er geen klok aan zit). Er zit hier wel degelijk een klok aan. Maar die klok gaat alleen naar de eerste flipflop en niet naar de naeren: die anderen worden niet geklokt dmv die klok.Wat gaan die meer beduidende flipflops gebruiken als klokingang: het feit dat de midner beduidende (meer naar links) van waarde veranderd is.Het is Q' die als klok dient voor de volgende: op dalende flankv an de Q zal e volgende reageren. Dat is een compacte implementatie. Nadeel: asyncrhoon voor de meer beduidende flipflops. Op het moment dat Q3 verandert is een hele poos na de klok. Naarmate er een flipflop bijkomt gaat dat altijd maar verder en verder van de klokflank afliggen. Als je teveel bits hebt, gat de laatste verandert wanneer de klok nog eens verandert of al eens veranderd is. Dat kan je je niet veroorloven: setupproblemen of overgangsverschijnselen.Dit is dus geen component om aan zeer hoge rates te gebruiken, toch niet als je vele bits hebt. 

\paragraph{Slide 28:} Als je snelheid wilt moet je synchroon gaan werken. Je hebt dan wel iets meer hardware nodig: concreet aangeven wanneer de volgende mag wijzigen: hangt af van vorige Q's en enabler.Je kan dit ook implementeren met 1 AND met 3 ingangen als snelheid belangrijk is.

\paragraph{Slide 29:} Veralgemenen: soort componenten dat je dan terugvindt: je wil uw teller kunnen initialiseren, je wil dat die naar boven en naar beneden kan tellen en dat je die kan cascaderen: component die dat voor 4 bit doet. As je er een voor 8 bit nodig hebt: 2 van 4 bit achter elkaar zetten.manier om dat te doen is hier weergegeven. We hebben al een ideehoe dat werkt voor een gewone synchrone teller. Daarnet hadden we een toggle flipflop. Als je dat laadbaar wilt maken kan je er geen T-flipflop zetten, je hebt dan een D-flipflop nodig en in de terugkoppeling zet je een XOR poort.In het kaki moet je iets algemeners zetten: niet om toe te laten van het te laden (zorgt de multiplexer toe), maar om te beslissen of je telt en of je naar boven of naar beneden telt.D/U*: up/downteller. Hoe moet je dat interpreteren: dat signaal heeft 2 taken: aangeven dat er naar boven dat er naar boven moet geteld worden en dat er naa rbeneden meot geteld worden. Dit kan met 1 draad omdat ze complementair zijn. We geven dit expliciet aan in de naam zodanig dat we duidelijke interpretatie hebben. D/U*=1 is actief hoog voor down, D/U*=0 is actief laag voor up.Er is een driebitsteller een een cascaderingsuitgang. Daarnaast is er een asynchrone clear en preset maar een syncrhone: als set/reset is: allemaal nullen of enen inladen.

\paragraph{Slide 30:} Naar de functionaliteit kijken: 2 uitgangen. Aan de ingang van de flipflop aan het cijfer liggen. Die enable is die naar de meer beduidende gaat. Als er mag geteld worden en dat geeft Ei aan, dan is het een XOR die we nodig hebben: van toestand vernaderen. Als er niet geteld mag worden, dan moet het hetzelfde blijven. Kan beschreven worden met een enkele XOR.Tweede uitgang: hangt niet alleen af van enable maar ook van of we naar boven of beneden tellen. In het voorbeeld: de meer beduidende bit moet veranderen als de minder beduidende 1 was en naar 0 gaat. Wanneer moet die uit de enable naar het hogere cijfer dan 1: binnenkomende is 1 en de minder beduidende bit is 1.Als je naar beneden telt is het het omgekeerde.Je had het ook met een Karnaughkaart kunnen maken, maar dan had je waarschijnlijk niet met een XOR-poort geimplementeerd geweest. Was niet fout geweest natuurlijk.

\paragraph{Slide 31:} Soms willen we geen binaire teller maar bv. een BCD-teller. Hoe maak je dat? Door tte implementeren wat juist gezegd is geweest: tellen op normale manier, maar als je detecteert dat je aan 9 gekomen bent, is het volgende niet 10 maar 0. je detgecteert dat in de onderste AND-poort. Als we dat detecteren, dan zal op de volgende klokflank er niet 10 op staan maar 0. je doet dan een syncrhone reset door er 0 in te laden. Dat kan in de andere richting even goed toegepast worden: van 0 naar 9 bij het naar beneden gaan.Alle andere sorten tellers kunnen dus ook met een binaire teller gemaakt worden en dan op het juiste moment de juiste waarde inladen. 

\paragraph{Slide 32:} Hoe in VHDL? Jammer genoeg bestaat er in VHDL niks om flipflops of geheugenlementen te beshcrhrjiven, dat is altijd impliciet. Da tmaakt het gevaarlijker: wat je bedoelde hbt als combinatorische schakeling kan een sequentiele worden.Waar zit de geheugenfunctie? Als je iets niet verandert, verwacht VHDL dat de oude waarde blijft staan. Er is dus bijna altijd impliciet een gehuegenfunctie. Je gaat onthouden wat eropstond, je moet dat gewoon toelaten.2 snippets: bij rehcts staat er een else, bij andere niet. Bij de rechtse ga je voor elke waarde van de klok en de data onmiddelijk kunnen bepalen wat op de uitgang staat. Als de data op de klok vernadert, komt er een eventueel nieuwe waarde op de uitgang. Links is dat niet het geval. Als de klok daar 0 9smag dis data zoveel veranderen als die iwlt, dat gaat geen ivnloed hebben. Wat je daar beschrijft is dus een latch: als de klok 1 is gaat de uitgang hetzelfde zijn als de ingang, de ingang wordt doorgegeven aan de uitgang. Als de data constant blijft en de klok verandert, als de klok 1 geworden is, dan ga je hetzelfde hebben: data wordt odorgegeven naar deuitgang. Op het moment dat de klok 0 wordt gebeurt er niks meer. Als je die code analyseerT: je schrijft een latch. Het feit dat je die else er niet bij hebt gezet kan betekenen dat je van een combinatorische naar een latch gaat. 

\paragraph{Slide 34:} we zijn geintereseerd ind e flank-gestuurde flipflops. Hoe? Niet op de waarde van de klok testen, maar op de verandering van de klok. Die if zegt dat als er een vernadering avn de klok is en ze is 1 geworden, dna zit je met een stijgende flank. Je kan ook gewoon de functie rising edge gebruiken, dan moet je alle mogelijkheden niet gaan testen.Er is nog een andere manier, maar die gaan we later zien. 

\paragraph{Slide 35:} We willen ook kunnen resetten en clearen. Als het syncrhoon is: binnen e test op de stijgende flank: alleen naar het resetsignaal kijken op de stijgende flank.a ls asynchroon: buiten de test op de stijgende flank. Waarom sommige dingen in het lichtgrijs: die ingangen moeten daar strikt gezien niet bijstaan want gaan alleen effect hebben wanneer er een stijgende klokflank is. Maar het is veiligheidshalve beter om alle ingangen te vermelden voor als je later aanpassingen wil maken.

\paragraph{Slide 36:} IPV gewoon de data door te geven naar de uitgang kan je ook een bwereking doorgeven, het resultaat van een bewerking. Komt neer op dat je een combinatorisch netwerk mee in rekening brengt in eht proces. Op die manier heb je de tekening rechtsboven beschreven met 1 parallelle uitdrukking, met 1 proces in plaats van met 4 parallelle uitdrukkingen. Functioneel gezien zijn ze equivalent. Toch ga je heel dikwijls zien wat ind e VHDL code staat omdat het efficienter is wanneer je gaat simuleren.Elke parallelle uitdrukking komt met een proces overeen. Bij simulatie is het eficienter om 1 proces te gebruiken.

\paragraph{Slide 37:} Vbn: registers. Op zichzelf is dat zeer eenvoudig: vb van schuifregister. We testen hie rook op stijgende klokflank. Als de shift 1 is gaan we opschuiven, anders doen we niks. Q(i) wordt Q(i+1) op het einde van het proces. In die loop ga je onthouden wat het op het einde gaat zijn, maar je gaat intermediair nog niks onthouden. Het doet er niet toe in welke volgorde ht gebuert, het kan evengoed op de rechtse manier geschreven worden: ganse vector schuift 1 plaats op.

\paragraph{Slide 39:} Het geheugen gaan we nu gebruiken om de totestand in te bweanren van de sequentieele schakeling. Bij een synchrone sequentiele shcakeling gaan we gebruik makenvan een klok (denk ik). Op alle andere ogenblikken kan het ons niet schelen hoe dat verandert. Alleen op het moment, liefst op de stijgende klokflank, dat er iets bekeken wordt.

\paragraph{Slide 40:} Hoe maken we zo'n ontwerp: eerst gaan we van onze beschrijving vertrekken end at vertalen naar een eenduidige beschrijving die niet fout geinterpreteerrd kan worden en maar tot 1 duidelijke werking van het systeem kan leiden. Dat is een teostandsdiagram of -tabl. Die beschrijft hoe je van de ene teostand naar de andere overgaat. We gaan dat aantal toestanden zo klein mogelijk proebren te maken want hoe midner toestnaden, hoe goedkoper de schakeling.De volgende stap is het implementeren vna het geheugen. Tot hier toe zijn die teostanden nog vrij abstract, maar je moet gaan zegegn hoe je dat in een flipflop gaat bewaren, met wat komt die bepaalde binaire combinatie overeen? $\rightarrow$ coderen van de toestanden.Om het geheugen te implementeren moet je bepalen wat voor flipflop je kiest. Dat heeft impact op hoe je de ingangen kiest.Laatste stap: implementatie van het cominatorisch deel. Enerzijds omde flipflops aan te sturen en anderzijds omd e uitgang aan te sturen.

\paragraph{Slide 41:} we hebben geizen dat er 2 types zijn: toestandsgebaseerd (uitgnag hangt enkel af van de toestand) en inputgebaseerd (uitgang hangt ook af van de input).

\paragraph{Slide 42:} We willen een schakeling maken met 1 in- en uitgang. Op die uitgang moet 1 komen als de vorige 2 klokperiodes de ingang 1 was. Je wil een opeenvolging vna twee enen detecteren. Als eerste maken we een toestandsdiagram. Iedere ellips is een toestand. Momenteel krijgen die nog symbolische namen. Wat er wel altijd is is dat elke toestand een betekenis heeft ej e moet daar ook ee betekenis aan toekennen, anders wordt eht moeilijk te begrijpen wanneer je naar een andere toestand terugkeert of wanneer je een nieuwe teostand nodig hebt.De uitgang hangt enkel af van de toestand op ti. De uitgang hangt dus alleen af van de toestand en je kan de waarde van die uitgang bij de toestand bij noteren: als de toestand A is, is de uitgang 0. die kan daarn terechtomen door te resetten of als er geen enen meer geweest zijn. Betekenis ervan: geeft aan dat er ervoor geen enen waren. In een toestandsdiagram kan je in principe niks asynchroon weergeven, vandaar wordt dat met een speciaal symbool weeergegeven: je hebt het in het echt nodig dat je dat asyncrhoon in een begintoestand kan krijgen (die gekartelde pijl).Vanuit die teostand moet je gaan kijken voor elke ingangscombinatie waar je terechtkomt, wat de volgende toestand is. Je kan maar 1 waarden hebben: ofwel 1 of 0. als die 0 is zijn er nog steeds geen enen opgetreden dus blijf je in die teostand. Als er een 1 optreedt, ga je naar een teostand waar het duidelijk is dat er 1 1 voorkwam.Als je vanuit die toestand een - hebt, herbegin je en ga je terug naar A. als je een 1 hebt ga je naar een nieuwe teostand die aangeeft dat er twee enen na elkaar zijn geweest. In dit geval ga je als uitgang 1 hebben dus is er een nieuwe toestand nodig. Als je opnieuw een 1 hebt blijf je in die teostand. Als je ene 0 hebt ga je terug naar A.Nu is er geen enkele toestand meer waarvoor niet alle combinaties beschreven zijn. Dit is een interpretatie van wat bovenaan in woorden staat.

\paragraph{Slide 43:} In detail beijken wat de betekenis is van al die getekende dingen: 	• ellips: toestand $\rightarrow$ niet de volledige beschrijving van e volledige voorgeschidenis en wat op dit moment gebeurt, maar het geeft enkel de voorgeschiedenis weer.Toetsand + pijlen/ingangen: beschrijven de volleidge teostnad van het systeem. Je bevindt u altijd op een pijl, nooit in een toestand. Als uw ingang verandert, vernader je niet van teostand maar van pijl.Je mag overspringen zodra er een klokflank is. Dan ga je naar de toestand waarde pijlnaar wees. Je gaat u onmiddelijk opnieuw op een pijl bevinden want je hebt een ingang. Die overgangen en toestanden, de enige verandering die daarin kan komen kan alleen wanneer er een klokflank geweest is. Wanneer we het hebben over een syncrhone sequentieele schakeling,d an is dat zo.Rode kader: heel belangrijk: in een synchrone sequentiele schakeling kan nooit een kloksignaal instaan. Nergens in dat shcema staat een kloksignaal. Dat is alleen impliciet aanwezig en dient om van de ene teostand naar de andere te gaan. 

\paragraph{Slide 44:} We kunnen dat ook in een toestandstabel zetten. Dat is juist hetzelfde om hetzelfde weer te geven. De volgende stap is het aantal toestanden reduceren tot een minimumaantal. In dit geval is dit een minimum aantal toestanen.

\paragraph{Slide 45:} Codering: je hebt tostanden die je nu in een geheugen moet gaan plaatsen. Je hebt minmum 2 flipflops nodig om die 3 toestanden te combineren.Je hebt verschillende mogelijkehden. Je moet dat niet doen zoals getoond, je mag de benaming in principe ook anders doen. Op zich maakt het wel veel verschil wat je daar kiest, gaan we nog zien. Er is nromaal altijd een begintoestand en het is de gewoonte om die met 0 overeen te laten komen. Daarna moet je het type flipflop kiezen.

\paragraph{Slide 46:} laatste stap: combinatorische schakeling ontwerpen: bepalen wat de toestand is en aansturing van de uitgang. Hoe vertrek je hier van om dat combinatorisch netwerk te bepalen? Die excitatietabel is hier nodig: verband tss veranderingen van toestand. Een D-flipflop is makkelijk om mee te werken wat wat je aan de ingang moet aanlegegn is de volgende toestand. Je moet er niet voor weten wat de huidige toestand is, gewoon wat de volgende is/moet zijn. Nu heb j een verband: uitgangen van combinatorische schakeling, huidige toestand en de ingang. Je kan dat ook in Karnaughkaarten neerschrijven. Er zijn 2 kaarten watnt je hebt D1 en D0. sLide 47: implementatie: basis: wat we al hadden, dan pas je toe wat in de Karnaughkaarten staat. De uitgang is gewoon de uitgang va die flipflop. Zelfs geen speciale hardware voor nodig.Nu eerste synchrone schakeling geimplementeerd. Je moet nakijken of dat wel werkt: controleren f je uw specs wel goed vertaald hebt naar een toestandsdiagram. Dit doe je meestal door een tijdsdiagram. Je moet alleen op de stijgende klokflank kijken, alles wat daartussen gebeurt is niet vanbelang. Verschil met inputgebaseerd systeem (nu een toestandsgebaseerd systeem).

\paragraph{Slide 48:} het is niet omdat je lokale optimaliseringen doet dat je tot globale optimaliseringen komt.Stel dat we van 4 toestanden vertrekken en we willen niet minimaliseren. Ook hier zullen twee flipflops nodig zijn. We gaan nu de getoonde tabel impelementeren. De overeenomstige schakeling is nu compacter, alleen is het niet duidelijk hoe je er geraakt bent: eerst inputgebaseerd opgelost en dan gezien dat het eenvoudiger is. Als we nu dezelfe ipmlementatie nemen en die aanpassen, komen we ook tot deze implementatie. Vanaf de vorgie vertrokken wat het niet evident om hier te komen.De stappen mooi na elkaar uitvoeren geeft meestal wel een compacte representatie maar niet altijd de beste oplossing.

\paragraph{Slide 50:} inputgebaseerd systeem: specs zijn ongeveer hetzelfde. We kijken nu niet wat de ingang op de twee vorige klokperiodes was, maar in de vorige en in de huidige: ingagng wordt bekeken op hetzelfde moement als de uitgang gebaseerd wordt. Toestandsdiagram is ongeveer dezelfde. De uitgangen staan nu echter niet bij de toestand maar bij de pijl: de pijl komt overeen met de combinatie van teostand en ingang en dat is wat je bij een teostandsgebaseerd systeeem hebt. Hier zou dat niet veel verschil maken want of w nu 0 is of 1, de uitgang is toch 0 vanuit A. maar in B is er wel een verschil voor z.Bij een inputsgebaseerd systeem is het iets moeilijker omdat je niet 1 uitgang voor een toestand hebt, maar n een aantal gevallen gaat dat leiden tot een kleiner aantal toestanden omdat je dat nit eerst ergens moet bewaren.  In dit geval leidt dat ertoe dat er maar 1 flipflop nodig is terwijl we er daarnet 2 nodig hadden.

\paragraph{Slide 51:} De uitgang is nu ok afhankelijk van de ingang. Zie ook overgang! 

\paragraph{Slide 52:} De rest van de stappen is ongeveer hetzelfde, alleen is het in dit voorbeeld iets simpeler. Je hebt ook veel beperktere kaarten want je hebt maar 2 variabelen. Voor de uitgang speelt ook de ingang mee (niet alleen de toestand).

\paragraph{Slide 53:} Als je hier de timing van bekijkt en je vergelijkt methet vorige is er wel een verschil: ingang speelt onmiddelijk mee in de uitgang. 

\paragraph{Slide 54:} VHDL: om een toestandsdiagram te beschrijven en de implementatie daarvan kan je dat in de Xilixomgeving gaan tekenen. Die is intelligent genoeg om dat stappenplan zelf te volgen en er zelf de juiste versie uit a te leiden.In de nieuweste versie kan je dat toestandsdiagram niet meer tekenen want dat werd niet gebruikt. Is even makkelijk in VHDL te gebruiken als dat te tekenen.

\paragraph{Slide 55:} VHDL beschrijft hardware: voor ieder stukje heb je hardware. Je kan de synchrone sequentiele schakeling altijd tekenen zoals links op de slide: stuk geheugen waar de toestand in bewaard wordt en dan 2 stukken combinatorische logica om output in te bwaren en de volgende toestand te bepalen.Rechts is het getekende toestandsdiagram. Heo dit implementeren? Je kan het op gedragsniveau omschrijve.

\paragraph{Slide 56:} Je kan het schema rechts volledig in VHDL beschrijven. Je hebt de ingangen eraan en de twee bits in elke bol op de vorige slide zet je bij uw Output. Dat is uw zwarte doos en verder beschrijf je dan hoe het werkt.Voor ieder van de blokjes heb je 1 proces. Je geeft aan wat de ingangen zijn, uitgnagne moeten niet.alle mogelijke toestanden die je hebt kunnen daarop komen te staan.Dit is dus een volledige beschrijving van wat rechts staat, op die puntjes na.Wat is er verschillend van de ene sequentieel eschakeling naar de andere: ingangen, toestanden kunnen anders zijn, maar groen en de 3 processen blijven hetzelfde.Je kan dus makkelijk een sjabloon maken dat vooor alle synchrone sequentiele schakelingen werkt. 

\paragraph{Slide 57:} dit is op zich niet moeilijker dan het toestandsdiagram teekenen. Je hebt bv. een register, wordtook beschreven in VHDL. Je moet wel invullen hoe de logica werkt. Niet hoe de coering werkt of de flipflops, de hardware moet dat maar oplsosen.

\paragraph{Slide 58:} beschrijft wat er in het toestandsdiagram staat: voor iedere toestand zeg je wat er afhankelijk vand e ingangen wat de volgende toestand zal zijn. 

\paragraph{Slide 59:} Uitngang bepalen, ook makkelijk. Wanneer je in VHDL iets beschrijft is dat even makeklijk als dat tekenen.

\paragraph{Slide 60:} wat hebben we niet gedaan: flipflops en codering vastgelegd $\rightarrow$ voor compiler. Als die dat niet goed zou doen, dan kan je hem ook terechtwijzen.Eerste manier: bijkomend attribuut aan toestand meegeven. 

\paragraph{Slide 61:} we hadden daarnet 3 teostanden nodig en 2 flipflops dus eigenlijk 4 mogelijke toestanden. We hadden van de 4e teostand een don't care gemaakt.. Je moet niet zoj zeker zijn dat dat niet kon optreden; bij het opstarten kan je er per ongelukin terechtkomen. Het kan zijn dat uw schakeling dan nooit meer correct werkt want de voorgeschiedenis gaat wijzigen. Om dat te voorkomen is het veiliger om geen don't cares te gebruiken. Gebruik die extra toestanden om te zorgen dat als je daarin zit zo snel mogelijk terug naar deintitiele toestand te gaan: even fout zijn maar daarna zorg je voor een correcte werking.Dat kan je doen door de don't cares in te vullen (makkelijk in VHDL: when others).

\end{document}